var x = "top", B = "bottom", V = "right", M = "left", Me = "auto", Kt = [x, B, V, M], St = "start", Ht = "end", mi = "clippingParents", Cn = "viewport", xt = "popper", _i = "reference", pn = Kt.reduce(function (n, t) { return n.concat([t + "-" + St, t + "-" + Ht]) }, []), Dn = [].concat(Kt, [Me]).reduce(function (n, t) { return n.concat([t, t + "-" + St, t + "-" + Ht]) }, []), Ei = "beforeRead", gi = "read", vi = "afterRead", bi = "beforeMain", yi = "main", Ai = "afterMain", Ti = "beforeWrite", wi = "write", Oi = "afterWrite", Si = [Ei, gi, vi, bi, yi, Ai, Ti, wi, Oi]; function tt(n) { return n ? (n.nodeName || "").toLowerCase() : null } function W(n) { if (n == null) return window; if (n.toString() !== "[object Window]") { var t = n.ownerDocument; return t && t.defaultView || window } return n } function Nt(n) { var t = W(n).Element; return n instanceof t || n instanceof Element } function F(n) { var t = W(n).HTMLElement; return n instanceof t || n instanceof HTMLElement } function Ln(n) { if (typeof ShadowRoot > "u") return !1; var t = W(n).ShadowRoot; return n instanceof t || n instanceof ShadowRoot } function Br(n) { var t = n.state; Object.keys(t.elements).forEach(function (e) { var s = t.styles[e] || {}, i = t.attributes[e] || {}, r = t.elements[e]; !F(r) || !tt(r) || (Object.assign(r.style, s), Object.keys(i).forEach(function (o) { var a = i[o]; a === !1 ? r.removeAttribute(o) : r.setAttribute(o, a === !0 ? "" : a) })) }) } function Vr(n) { var t = n.state, e = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function () { Object.keys(t.elements).forEach(function (s) { var i = t.elements[s], r = t.attributes[s] || {}, o = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : e[s]), a = o.reduce(function (c, l) { return c[l] = "", c }, {}); !F(i) || !tt(i) || (Object.assign(i.style, a), Object.keys(r).forEach(function (c) { i.removeAttribute(c) })) }) } } const Rn = { name: "applyStyles", enabled: !0, phase: "write", fn: Br, effect: Vr, requires: ["computeStyles"] }; function Z(n) { return n.split("-")[0] } var wt = Math.max, $e = Math.min, Bt = Math.round; function mn() { var n = navigator.userAgentData; return n != null && n.brands ? n.brands.map(function (t) { return t.brand + "/" + t.version }).join(" ") : navigator.userAgent } function Ni() { return !/^((?!chrome|android).)*safari/i.test(mn()) } function Vt(n, t, e) { t === void 0 && (t = !1), e === void 0 && (e = !1); var s = n.getBoundingClientRect(), i = 1, r = 1; t && F(n) && (i = n.offsetWidth > 0 && Bt(s.width) / n.offsetWidth || 1, r = n.offsetHeight > 0 && Bt(s.height) / n.offsetHeight || 1); var o = Nt(n) ? W(n) : window, a = o.visualViewport, c = !Ni() && e, l = (s.left + (c && a ? a.offsetLeft : 0)) / i, u = (s.top + (c && a ? a.offsetTop : 0)) / r, h = s.width / i, E = s.height / r; return { width: h, height: E, top: u, right: l + h, bottom: u + E, left: l, x: l, y: u } } function $n(n) { var t = Vt(n), e = n.offsetWidth, s = n.offsetHeight; return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), { x: n.offsetLeft, y: n.offsetTop, width: e, height: s } } function Ci(n, t) { var e = t.getRootNode && t.getRootNode(); if (n.contains(t)) return !0; if (e && Ln(e)) { var s = t; do { if (s && n.isSameNode(s)) return !0; s = s.parentNode || s.host } while (s) } return !1 } function it(n) { return W(n).getComputedStyle(n) } function Ur(n) { return ["table", "td", "th"].indexOf(tt(n)) >= 0 } function dt(n) { return ((Nt(n) ? n.ownerDocument : n.document) || window.document).documentElement } function ke(n) { return tt(n) === "html" ? n : n.assignedSlot || n.parentNode || (Ln(n) ? n.host : null) || dt(n) } function os(n) { return !F(n) || it(n).position === "fixed" ? null : n.offsetParent } function jr(n) { var t = /firefox/i.test(mn()), e = /Trident/i.test(mn()); if (e && F(n)) { var s = it(n); if (s.position === "fixed") return null } var i = ke(n); for (Ln(i) && (i = i.host); F(i) && ["html", "body"].indexOf(tt(i)) < 0;) { var r = it(i); if (r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].indexOf(r.willChange) !== -1 || t && r.willChange === "filter" || t && r.filter && r.filter !== "none") return i; i = i.parentNode } return null } function le(n) { for (var t = W(n), e = os(n); e && Ur(e) && it(e).position === "static";)e = os(e); return e && (tt(e) === "html" || tt(e) === "body" && it(e).position === "static") ? t : e || jr(n) || t } function In(n) { return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y" } function ie(n, t, e) { return wt(n, $e(t, e)) } function Fr(n, t, e) { var s = ie(n, t, e); return s > e ? e : s } function Di() { return { top: 0, right: 0, bottom: 0, left: 0 } } function Li(n) { return Object.assign({}, Di(), n) } function Ri(n, t) { return t.reduce(function (e, s) { return e[s] = n, e }, {}) } var Wr = function (t, e) { return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, Li(typeof t != "number" ? t : Ri(t, Kt)) }; function Kr(n) { var t, e = n.state, s = n.name, i = n.options, r = e.elements.arrow, o = e.modifiersData.popperOffsets, a = Z(e.placement), c = In(a), l = [M, V].indexOf(a) >= 0, u = l ? "height" : "width"; if (!(!r || !o)) { var h = Wr(i.padding, e), E = $n(r), _ = c === "y" ? x : M, p = c === "y" ? B : V, m = e.rects.reference[u] + e.rects.reference[c] - o[c] - e.rects.popper[u], v = o[c] - e.rects.reference[c], y = le(r), T = y ? c === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, S = m / 2 - v / 2, b = h[_], w = T - E[u] - h[p], O = T / 2 - E[u] / 2 + S, N = ie(b, O, w), R = c; e.modifiersData[s] = (t = {}, t[R] = N, t.centerOffset = N - O, t) } } function Yr(n) { var t = n.state, e = n.options, s = e.element, i = s === void 0 ? "[data-popper-arrow]" : s; i != null && (typeof i == "string" && (i = t.elements.popper.querySelector(i), !i) || Ci(t.elements.popper, i) && (t.elements.arrow = i)) } const $i = { name: "arrow", enabled: !0, phase: "main", fn: Kr, effect: Yr, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Ut(n) { return n.split("-")[1] } var qr = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function zr(n) { var t = n.x, e = n.y, s = window, i = s.devicePixelRatio || 1; return { x: Bt(t * i) / i || 0, y: Bt(e * i) / i || 0 } } function as(n) { var t, e = n.popper, s = n.popperRect, i = n.placement, r = n.variation, o = n.offsets, a = n.position, c = n.gpuAcceleration, l = n.adaptive, u = n.roundOffsets, h = n.isFixed, E = o.x, _ = E === void 0 ? 0 : E, p = o.y, m = p === void 0 ? 0 : p, v = typeof u == "function" ? u({ x: _, y: m }) : { x: _, y: m }; _ = v.x, m = v.y; var y = o.hasOwnProperty("x"), T = o.hasOwnProperty("y"), S = M, b = x, w = window; if (l) { var O = le(e), N = "clientHeight", R = "clientWidth"; if (O === W(e) && (O = dt(e), it(O).position !== "static" && a === "absolute" && (N = "scrollHeight", R = "scrollWidth")), O = O, i === x || (i === M || i === V) && r === Ht) { b = B; var L = h && O === w && w.visualViewport ? w.visualViewport.height : O[N]; m -= L - s.height, m *= c ? 1 : -1 } if (i === M || (i === x || i === B) && r === Ht) { S = V; var C = h && O === w && w.visualViewport ? w.visualViewport.width : O[R]; _ -= C - s.width, _ *= c ? 1 : -1 } } var I = Object.assign({ position: a }, l && qr), q = u === !0 ? zr({ x: _, y: m }) : { x: _, y: m }; if (_ = q.x, m = q.y, c) { var P; return Object.assign({}, I, (P = {}, P[b] = T ? "0" : "", P[S] = y ? "0" : "", P.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + _ + "px, " + m + "px)" : "translate3d(" + _ + "px, " + m + "px, 0)", P)) } return Object.assign({}, I, (t = {}, t[b] = T ? m + "px" : "", t[S] = y ? _ + "px" : "", t.transform = "", t)) } function Gr(n) { var t = n.state, e = n.options, s = e.gpuAcceleration, i = s === void 0 ? !0 : s, r = e.adaptive, o = r === void 0 ? !0 : r, a = e.roundOffsets, c = a === void 0 ? !0 : a, l = { placement: Z(t.placement), variation: Ut(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: i, isFixed: t.options.strategy === "fixed" }; t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, as(Object.assign({}, l, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: c })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, as(Object.assign({}, l, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: c })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) } const Pn = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: Gr, data: {} }; var be = { passive: !0 }; function Xr(n) { var t = n.state, e = n.instance, s = n.options, i = s.scroll, r = i === void 0 ? !0 : i, o = s.resize, a = o === void 0 ? !0 : o, c = W(t.elements.popper), l = [].concat(t.scrollParents.reference, t.scrollParents.popper); return r && l.forEach(function (u) { u.addEventListener("scroll", e.update, be) }), a && c.addEventListener("resize", e.update, be), function () { r && l.forEach(function (u) { u.removeEventListener("scroll", e.update, be) }), a && c.removeEventListener("resize", e.update, be) } } const xn = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: Xr, data: {} }; var Jr = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Oe(n) { return n.replace(/left|right|bottom|top/g, function (t) { return Jr[t] }) } var Qr = { start: "end", end: "start" }; function cs(n) { return n.replace(/start|end/g, function (t) { return Qr[t] }) } function Mn(n) { var t = W(n), e = t.pageXOffset, s = t.pageYOffset; return { scrollLeft: e, scrollTop: s } } function kn(n) { return Vt(dt(n)).left + Mn(n).scrollLeft } function Zr(n, t) { var e = W(n), s = dt(n), i = e.visualViewport, r = s.clientWidth, o = s.clientHeight, a = 0, c = 0; if (i) { r = i.width, o = i.height; var l = Ni(); (l || !l && t === "fixed") && (a = i.offsetLeft, c = i.offsetTop) } return { width: r, height: o, x: a + kn(n), y: c } } function to(n) { var t, e = dt(n), s = Mn(n), i = (t = n.ownerDocument) == null ? void 0 : t.body, r = wt(e.scrollWidth, e.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = wt(e.scrollHeight, e.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -s.scrollLeft + kn(n), c = -s.scrollTop; return it(i || e).direction === "rtl" && (a += wt(e.clientWidth, i ? i.clientWidth : 0) - r), { width: r, height: o, x: a, y: c } } function Hn(n) { var t = it(n), e = t.overflow, s = t.overflowX, i = t.overflowY; return /auto|scroll|overlay|hidden/.test(e + i + s) } function Ii(n) { return ["html", "body", "#document"].indexOf(tt(n)) >= 0 ? n.ownerDocument.body : F(n) && Hn(n) ? n : Ii(ke(n)) } function re(n, t) { var e; t === void 0 && (t = []); var s = Ii(n), i = s === ((e = n.ownerDocument) == null ? void 0 : e.body), r = W(s), o = i ? [r].concat(r.visualViewport || [], Hn(s) ? s : []) : s, a = t.concat(o); return i ? a : a.concat(re(ke(o))) } function _n(n) { return Object.assign({}, n, { left: n.x, top: n.y, right: n.x + n.width, bottom: n.y + n.height }) } function eo(n, t) { var e = Vt(n, !1, t === "fixed"); return e.top = e.top + n.clientTop, e.left = e.left + n.clientLeft, e.bottom = e.top + n.clientHeight, e.right = e.left + n.clientWidth, e.width = n.clientWidth, e.height = n.clientHeight, e.x = e.left, e.y = e.top, e } function ls(n, t, e) { return t === Cn ? _n(Zr(n, e)) : Nt(t) ? eo(t, e) : _n(to(dt(n))) } function no(n) { var t = re(ke(n)), e = ["absolute", "fixed"].indexOf(it(n).position) >= 0, s = e && F(n) ? le(n) : n; return Nt(s) ? t.filter(function (i) { return Nt(i) && Ci(i, s) && tt(i) !== "body" }) : [] } function so(n, t, e, s) { var i = t === "clippingParents" ? no(n) : [].concat(t), r = [].concat(i, [e]), o = r[0], a = r.reduce(function (c, l) { var u = ls(n, l, s); return c.top = wt(u.top, c.top), c.right = $e(u.right, c.right), c.bottom = $e(u.bottom, c.bottom), c.left = wt(u.left, c.left), c }, ls(n, o, s)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function Pi(n) { var t = n.reference, e = n.element, s = n.placement, i = s ? Z(s) : null, r = s ? Ut(s) : null, o = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, c; switch (i) { case x: c = { x: o, y: t.y - e.height }; break; case B: c = { x: o, y: t.y + t.height }; break; case V: c = { x: t.x + t.width, y: a }; break; case M: c = { x: t.x - e.width, y: a }; break; default: c = { x: t.x, y: t.y } }var l = i ? In(i) : null; if (l != null) { var u = l === "y" ? "height" : "width"; switch (r) { case St: c[l] = c[l] - (t[u] / 2 - e[u] / 2); break; case Ht: c[l] = c[l] + (t[u] / 2 - e[u] / 2); break } } return c } function jt(n, t) { t === void 0 && (t = {}); var e = t, s = e.placement, i = s === void 0 ? n.placement : s, r = e.strategy, o = r === void 0 ? n.strategy : r, a = e.boundary, c = a === void 0 ? mi : a, l = e.rootBoundary, u = l === void 0 ? Cn : l, h = e.elementContext, E = h === void 0 ? xt : h, _ = e.altBoundary, p = _ === void 0 ? !1 : _, m = e.padding, v = m === void 0 ? 0 : m, y = Li(typeof v != "number" ? v : Ri(v, Kt)), T = E === xt ? _i : xt, S = n.rects.popper, b = n.elements[p ? T : E], w = so(Nt(b) ? b : b.contextElement || dt(n.elements.popper), c, u, o), O = Vt(n.elements.reference), N = Pi({ reference: O, element: S, strategy: "absolute", placement: i }), R = _n(Object.assign({}, S, N)), L = E === xt ? R : O, C = { top: w.top - L.top + y.top, bottom: L.bottom - w.bottom + y.bottom, left: w.left - L.left + y.left, right: L.right - w.right + y.right }, I = n.modifiersData.offset; if (E === xt && I) { var q = I[i]; Object.keys(C).forEach(function (P) { var pt = [V, B].indexOf(P) >= 0 ? 1 : -1, mt = [x, B].indexOf(P) >= 0 ? "y" : "x"; C[P] += q[mt] * pt }) } return C } function io(n, t) { t === void 0 && (t = {}); var e = t, s = e.placement, i = e.boundary, r = e.rootBoundary, o = e.padding, a = e.flipVariations, c = e.allowedAutoPlacements, l = c === void 0 ? Dn : c, u = Ut(s), h = u ? a ? pn : pn.filter(function (p) { return Ut(p) === u }) : Kt, E = h.filter(function (p) { return l.indexOf(p) >= 0 }); E.length === 0 && (E = h); var _ = E.reduce(function (p, m) { return p[m] = jt(n, { placement: m, boundary: i, rootBoundary: r, padding: o })[Z(m)], p }, {}); return Object.keys(_).sort(function (p, m) { return _[p] - _[m] }) } function ro(n) { if (Z(n) === Me) return []; var t = Oe(n); return [cs(n), t, cs(t)] } function oo(n) { var t = n.state, e = n.options, s = n.name; if (!t.modifiersData[s]._skip) { for (var i = e.mainAxis, r = i === void 0 ? !0 : i, o = e.altAxis, a = o === void 0 ? !0 : o, c = e.fallbackPlacements, l = e.padding, u = e.boundary, h = e.rootBoundary, E = e.altBoundary, _ = e.flipVariations, p = _ === void 0 ? !0 : _, m = e.allowedAutoPlacements, v = t.options.placement, y = Z(v), T = y === v, S = c || (T || !p ? [Oe(v)] : ro(v)), b = [v].concat(S).reduce(function ($t, ot) { return $t.concat(Z(ot) === Me ? io(t, { placement: ot, boundary: u, rootBoundary: h, padding: l, flipVariations: p, allowedAutoPlacements: m }) : ot) }, []), w = t.rects.reference, O = t.rects.popper, N = new Map, R = !0, L = b[0], C = 0; C < b.length; C++) { var I = b[C], q = Z(I), P = Ut(I) === St, pt = [x, B].indexOf(q) >= 0, mt = pt ? "width" : "height", H = jt(t, { placement: I, boundary: u, rootBoundary: h, altBoundary: E, padding: l }), z = pt ? P ? V : M : P ? B : x; w[mt] > O[mt] && (z = Oe(z)); var me = Oe(z), _t = []; if (r && _t.push(H[q] <= 0), a && _t.push(H[z] <= 0, H[me] <= 0), _t.every(function ($t) { return $t })) { L = I, R = !1; break } N.set(I, _t) } if (R) for (var _e = p ? 3 : 1, Xe = function (ot) { var Xt = b.find(function (ge) { var Et = N.get(ge); if (Et) return Et.slice(0, ot).every(function (Je) { return Je }) }); if (Xt) return L = Xt, "break" }, Gt = _e; Gt > 0; Gt--) { var Ee = Xe(Gt); if (Ee === "break") break } t.placement !== L && (t.modifiersData[s]._skip = !0, t.placement = L, t.reset = !0) } } const xi = { name: "flip", enabled: !0, phase: "main", fn: oo, requiresIfExists: ["offset"], data: { _skip: !1 } }; function us(n, t, e) { return e === void 0 && (e = { x: 0, y: 0 }), { top: n.top - t.height - e.y, right: n.right - t.width + e.x, bottom: n.bottom - t.height + e.y, left: n.left - t.width - e.x } } function fs(n) { return [x, V, B, M].some(function (t) { return n[t] >= 0 }) } function ao(n) { var t = n.state, e = n.name, s = t.rects.reference, i = t.rects.popper, r = t.modifiersData.preventOverflow, o = jt(t, { elementContext: "reference" }), a = jt(t, { altBoundary: !0 }), c = us(o, s), l = us(a, i, r), u = fs(c), h = fs(l); t.modifiersData[e] = { referenceClippingOffsets: c, popperEscapeOffsets: l, isReferenceHidden: u, hasPopperEscaped: h }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": h }) } const Mi = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: ao }; function co(n, t, e) { var s = Z(n), i = [M, x].indexOf(s) >= 0 ? -1 : 1, r = typeof e == "function" ? e(Object.assign({}, t, { placement: n })) : e, o = r[0], a = r[1]; return o = o || 0, a = (a || 0) * i, [M, V].indexOf(s) >= 0 ? { x: a, y: o } : { x: o, y: a } } function lo(n) { var t = n.state, e = n.options, s = n.name, i = e.offset, r = i === void 0 ? [0, 0] : i, o = Dn.reduce(function (u, h) { return u[h] = co(h, t.rects, r), u }, {}), a = o[t.placement], c = a.x, l = a.y; t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += c, t.modifiersData.popperOffsets.y += l), t.modifiersData[s] = o } const ki = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: lo }; function uo(n) { var t = n.state, e = n.name; t.modifiersData[e] = Pi({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) } const Bn = { name: "popperOffsets", enabled: !0, phase: "read", fn: uo, data: {} }; function fo(n) { return n === "x" ? "y" : "x" } function ho(n) { var t = n.state, e = n.options, s = n.name, i = e.mainAxis, r = i === void 0 ? !0 : i, o = e.altAxis, a = o === void 0 ? !1 : o, c = e.boundary, l = e.rootBoundary, u = e.altBoundary, h = e.padding, E = e.tether, _ = E === void 0 ? !0 : E, p = e.tetherOffset, m = p === void 0 ? 0 : p, v = jt(t, { boundary: c, rootBoundary: l, padding: h, altBoundary: u }), y = Z(t.placement), T = Ut(t.placement), S = !T, b = In(y), w = fo(b), O = t.modifiersData.popperOffsets, N = t.rects.reference, R = t.rects.popper, L = typeof m == "function" ? m(Object.assign({}, t.rects, { placement: t.placement })) : m, C = typeof L == "number" ? { mainAxis: L, altAxis: L } : Object.assign({ mainAxis: 0, altAxis: 0 }, L), I = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, q = { x: 0, y: 0 }; if (O) { if (r) { var P, pt = b === "y" ? x : M, mt = b === "y" ? B : V, H = b === "y" ? "height" : "width", z = O[b], me = z + v[pt], _t = z - v[mt], _e = _ ? -R[H] / 2 : 0, Xe = T === St ? N[H] : R[H], Gt = T === St ? -R[H] : -N[H], Ee = t.elements.arrow, $t = _ && Ee ? $n(Ee) : { width: 0, height: 0 }, ot = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : Di(), Xt = ot[pt], ge = ot[mt], Et = ie(0, N[H], $t[H]), Je = S ? N[H] / 2 - _e - Et - Xt - C.mainAxis : Xe - Et - Xt - C.mainAxis, Ir = S ? -N[H] / 2 + _e + Et + ge + C.mainAxis : Gt + Et + ge + C.mainAxis, Qe = t.elements.arrow && le(t.elements.arrow), Pr = Qe ? b === "y" ? Qe.clientTop || 0 : Qe.clientLeft || 0 : 0, Jn = (P = I == null ? void 0 : I[b]) != null ? P : 0, xr = z + Je - Jn - Pr, Mr = z + Ir - Jn, Qn = ie(_ ? $e(me, xr) : me, z, _ ? wt(_t, Mr) : _t); O[b] = Qn, q[b] = Qn - z } if (a) { var Zn, kr = b === "x" ? x : M, Hr = b === "x" ? B : V, gt = O[w], ve = w === "y" ? "height" : "width", ts = gt + v[kr], es = gt - v[Hr], Ze = [x, M].indexOf(y) !== -1, ns = (Zn = I == null ? void 0 : I[w]) != null ? Zn : 0, ss = Ze ? ts : gt - N[ve] - R[ve] - ns + C.altAxis, is = Ze ? gt + N[ve] + R[ve] - ns - C.altAxis : es, rs = _ && Ze ? Fr(ss, gt, is) : ie(_ ? ss : ts, gt, _ ? is : es); O[w] = rs, q[w] = rs - gt } t.modifiersData[s] = q } } const Hi = { name: "preventOverflow", enabled: !0, phase: "main", fn: ho, requiresIfExists: ["offset"] }; function po(n) { return { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop } } function mo(n) { return n === W(n) || !F(n) ? Mn(n) : po(n) } function _o(n) { var t = n.getBoundingClientRect(), e = Bt(t.width) / n.offsetWidth || 1, s = Bt(t.height) / n.offsetHeight || 1; return e !== 1 || s !== 1 } function Eo(n, t, e) { e === void 0 && (e = !1); var s = F(t), i = F(t) && _o(t), r = dt(t), o = Vt(n, i, e), a = { scrollLeft: 0, scrollTop: 0 }, c = { x: 0, y: 0 }; return (s || !s && !e) && ((tt(t) !== "body" || Hn(r)) && (a = mo(t)), F(t) ? (c = Vt(t, !0), c.x += t.clientLeft, c.y += t.clientTop) : r && (c.x = kn(r))), { x: o.left + a.scrollLeft - c.x, y: o.top + a.scrollTop - c.y, width: o.width, height: o.height } } function go(n) { var t = new Map, e = new Set, s = []; n.forEach(function (r) { t.set(r.name, r) }); function i(r) { e.add(r.name); var o = [].concat(r.requires || [], r.requiresIfExists || []); o.forEach(function (a) { if (!e.has(a)) { var c = t.get(a); c && i(c) } }), s.push(r) } return n.forEach(function (r) { e.has(r.name) || i(r) }), s } function vo(n) { var t = go(n); return Si.reduce(function (e, s) { return e.concat(t.filter(function (i) { return i.phase === s })) }, []) } function bo(n) { var t; return function () { return t || (t = new Promise(function (e) { Promise.resolve().then(function () { t = void 0, e(n()) }) })), t } } function yo(n) { var t = n.reduce(function (e, s) { var i = e[s.name]; return e[s.name] = i ? Object.assign({}, i, s, { options: Object.assign({}, i.options, s.options), data: Object.assign({}, i.data, s.data) }) : s, e }, {}); return Object.keys(t).map(function (e) { return t[e] }) } var ds = { placement: "bottom", modifiers: [], strategy: "absolute" }; function hs() { for (var n = arguments.length, t = new Array(n), e = 0; e < n; e++)t[e] = arguments[e]; return !t.some(function (s) { return !(s && typeof s.getBoundingClientRect == "function") }) } function He(n) { n === void 0 && (n = {}); var t = n, e = t.defaultModifiers, s = e === void 0 ? [] : e, i = t.defaultOptions, r = i === void 0 ? ds : i; return function (a, c, l) { l === void 0 && (l = r); var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, ds, r), modifiersData: {}, elements: { reference: a, popper: c }, attributes: {}, styles: {} }, h = [], E = !1, _ = { state: u, setOptions: function (y) { var T = typeof y == "function" ? y(u.options) : y; m(), u.options = Object.assign({}, r, u.options, T), u.scrollParents = { reference: Nt(a) ? re(a) : a.contextElement ? re(a.contextElement) : [], popper: re(c) }; var S = vo(yo([].concat(s, u.options.modifiers))); return u.orderedModifiers = S.filter(function (b) { return b.enabled }), p(), _.update() }, forceUpdate: function () { if (!E) { var y = u.elements, T = y.reference, S = y.popper; if (hs(T, S)) { u.rects = { reference: Eo(T, le(S), u.options.strategy === "fixed"), popper: $n(S) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function (C) { return u.modifiersData[C.name] = Object.assign({}, C.data) }); for (var b = 0; b < u.orderedModifiers.length; b++) { if (u.reset === !0) { u.reset = !1, b = -1; continue } var w = u.orderedModifiers[b], O = w.fn, N = w.options, R = N === void 0 ? {} : N, L = w.name; typeof O == "function" && (u = O({ state: u, options: R, name: L, instance: _ }) || u) } } } }, update: bo(function () { return new Promise(function (v) { _.forceUpdate(), v(u) }) }), destroy: function () { m(), E = !0 } }; if (!hs(a, c)) return _; _.setOptions(l).then(function (v) { !E && l.onFirstUpdate && l.onFirstUpdate(v) }); function p() { u.orderedModifiers.forEach(function (v) { var y = v.name, T = v.options, S = T === void 0 ? {} : T, b = v.effect; if (typeof b == "function") { var w = b({ state: u, name: y, instance: _, options: S }), O = function () { }; h.push(w || O) } }) } function m() { h.forEach(function (v) { return v() }), h = [] } return _ } } var Ao = He(), To = [xn, Bn, Pn, Rn], wo = He({ defaultModifiers: To }), Oo = [xn, Bn, Pn, Rn, ki, xi, Hi, $i, Mi], Vn = He({ defaultModifiers: Oo }); const Bi = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: Ai, afterRead: vi, afterWrite: Oi, applyStyles: Rn, arrow: $i, auto: Me, basePlacements: Kt, beforeMain: bi, beforeRead: Ei, beforeWrite: Ti, bottom: B, clippingParents: mi, computeStyles: Pn, createPopper: Vn, createPopperBase: Ao, createPopperLite: wo, detectOverflow: jt, end: Ht, eventListeners: xn, flip: xi, hide: Mi, left: M, main: yi, modifierPhases: Si, offset: ki, placements: Dn, popper: xt, popperGenerator: He, popperOffsets: Bn, preventOverflow: Hi, read: gi, reference: _i, right: V, start: St, top: x, variationPlacements: pn, viewport: Cn, write: wi }, Symbol.toStringTag, { value: "Module" }));/*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */const So = 1e6, No = 1e3, En = "transitionend", Co = n => n == null ? `${n}` : {}.toString.call(n).match(/\s([a-z]+)/i)[1].toLowerCase(), Do = n => { do n += Math.floor(Math.random() * So); while (document.getElementById(n)); return n }, Vi = n => { let t = n.getAttribute("data-bs-target"); if (!t || t === "#") { let e = n.getAttribute("href"); if (!e || !e.includes("#") && !e.startsWith(".")) return null; e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), t = e && e !== "#" ? e.trim() : null } return t }, Un = n => { const t = Vi(n); return t && document.querySelector(t) ? t : null }, lt = n => { const t = Vi(n); return t ? document.querySelector(t) : null }, Lo = n => { if (!n) return 0; let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(n); const s = Number.parseFloat(t), i = Number.parseFloat(e); return !s && !i ? 0 : (t = t.split(",")[0], e = e.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * No) }, Ui = n => { n.dispatchEvent(new Event(En)) }, Ct = n => !n || typeof n != "object" ? !1 : (typeof n.jquery < "u" && (n = n[0]), typeof n.nodeType < "u"), ut = n => Ct(n) ? n.jquery ? n[0] : n : typeof n == "string" && n.length > 0 ? document.querySelector(n) : null, et = (n, t, e) => { Object.keys(e).forEach(s => { const i = e[s], r = t[s], o = r && Ct(r) ? "element" : Co(r); if (!new RegExp(i).test(o)) throw new TypeError(`${n.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${i}".`) }) }, ue = n => !Ct(n) || n.getClientRects().length === 0 ? !1 : getComputedStyle(n).getPropertyValue("visibility") === "visible", Ot = n => !n || n.nodeType !== Node.ELEMENT_NODE || n.classList.contains("disabled") ? !0 : typeof n.disabled < "u" ? n.disabled : n.hasAttribute("disabled") && n.getAttribute("disabled") !== "false", ji = n => { if (!document.documentElement.attachShadow) return null; if (typeof n.getRootNode == "function") { const t = n.getRootNode(); return t instanceof ShadowRoot ? t : null } return n instanceof ShadowRoot ? n : n.parentNode ? ji(n.parentNode) : null }, Ie = () => { }, Yt = n => { n.offsetHeight }, Fi = () => { const { jQuery: n } = window; return n && !document.body.hasAttribute("data-bs-no-jquery") ? n : null }, tn = [], Ro = n => { document.readyState === "loading" ? (tn.length || document.addEventListener("DOMContentLoaded", () => { tn.forEach(t => t()) }), tn.push(n)) : n() }, k = () => document.documentElement.dir === "rtl", K = n => { Ro(() => { const t = Fi(); if (t) { const e = n.NAME, s = t.fn[e]; t.fn[e] = n.jQueryInterface, t.fn[e].Constructor = n, t.fn[e].noConflict = () => (t.fn[e] = s, n.jQueryInterface) } }) }, Tt = n => { typeof n == "function" && n() }, Wi = (n, t, e = !0) => { if (!e) { Tt(n); return } const s = 5, i = Lo(t) + s; let r = !1; const o = ({ target: a }) => { a === t && (r = !0, t.removeEventListener(En, o), Tt(n)) }; t.addEventListener(En, o), setTimeout(() => { r || Ui(t) }, i) }, Ki = (n, t, e, s) => { let i = n.indexOf(t); if (i === -1) return n[!e && s ? n.length - 1 : 0]; const r = n.length; return i += e ? 1 : -1, s && (i = (i + r) % r), n[Math.max(0, Math.min(i, r - 1))] }, $o = /[^.]*(?=\..*)\.|.*/, Io = /\..*/, Po = /::\d+$/, en = {}; let ps = 1; const xo = { mouseenter: "mouseover", mouseleave: "mouseout" }, Mo = /^(mouseenter|mouseleave)/i, Yi = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function qi(n, t) { return t && `${t}::${ps++}` || n.uidEvent || ps++ } function zi(n) { const t = qi(n); return n.uidEvent = t, en[t] = en[t] || {}, en[t] } function ko(n, t) { return function e(s) { return s.delegateTarget = n, e.oneOff && d.off(n, s.type, t), t.apply(n, [s]) } } function Ho(n, t, e) { return function s(i) { const r = n.querySelectorAll(t); for (let { target: o } = i; o && o !== this; o = o.parentNode)for (let a = r.length; a--;)if (r[a] === o) return i.delegateTarget = o, s.oneOff && d.off(n, i.type, t, e), e.apply(o, [i]); return null } } function Gi(n, t, e = null) { const s = Object.keys(n); for (let i = 0, r = s.length; i < r; i++) { const o = n[s[i]]; if (o.originalHandler === t && o.delegationSelector === e) return o } return null } function Xi(n, t, e) { const s = typeof t == "string", i = s ? e : t; let r = Ji(n); return Yi.has(r) || (r = n), [s, i, r] } function ms(n, t, e, s, i) { if (typeof t != "string" || !n) return; if (e || (e = s, s = null), Mo.test(t)) { const _ = p => function (m) { if (!m.relatedTarget || m.relatedTarget !== m.delegateTarget && !m.delegateTarget.contains(m.relatedTarget)) return p.call(this, m) }; s ? s = _(s) : e = _(e) } const [r, o, a] = Xi(t, e, s), c = zi(n), l = c[a] || (c[a] = {}), u = Gi(l, o, r ? e : null); if (u) { u.oneOff = u.oneOff && i; return } const h = qi(o, t.replace($o, "")), E = r ? Ho(n, e, s) : ko(n, e); E.delegationSelector = r ? e : null, E.originalHandler = o, E.oneOff = i, E.uidEvent = h, l[h] = E, n.addEventListener(a, E, r) } function gn(n, t, e, s, i) { const r = Gi(t[e], s, i); r && (n.removeEventListener(e, r, Boolean(i)), delete t[e][r.uidEvent]) } function Bo(n, t, e, s) { const i = t[e] || {}; Object.keys(i).forEach(r => { if (r.includes(s)) { const o = i[r]; gn(n, t, e, o.originalHandler, o.delegationSelector) } }) } function Ji(n) { return n = n.replace(Io, ""), xo[n] || n } const d = { on(n, t, e, s) { ms(n, t, e, s, !1) }, one(n, t, e, s) { ms(n, t, e, s, !0) }, off(n, t, e, s) { if (typeof t != "string" || !n) return; const [i, r, o] = Xi(t, e, s), a = o !== t, c = zi(n), l = t.startsWith("."); if (typeof r < "u") { if (!c || !c[o]) return; gn(n, c, o, r, i ? e : null); return } l && Object.keys(c).forEach(h => { Bo(n, c, h, t.slice(1)) }); const u = c[o] || {}; Object.keys(u).forEach(h => { const E = h.replace(Po, ""); if (!a || t.includes(E)) { const _ = u[h]; gn(n, c, o, _.originalHandler, _.delegationSelector) } }) }, trigger(n, t, e) { if (typeof t != "string" || !n) return null; const s = Fi(), i = Ji(t), r = t !== i, o = Yi.has(i); let a, c = !0, l = !0, u = !1, h = null; return r && s && (a = s.Event(t, e), s(n).trigger(a), c = !a.isPropagationStopped(), l = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), o ? (h = document.createEvent("HTMLEvents"), h.initEvent(i, c, !0)) : h = new CustomEvent(t, { bubbles: c, cancelable: !0 }), typeof e < "u" && Object.keys(e).forEach(E => { Object.defineProperty(h, E, { get() { return e[E] } }) }), u && h.preventDefault(), l && n.dispatchEvent(h), h.defaultPrevented && typeof a < "u" && a.preventDefault(), h } }, at = new Map, oe = { set(n, t, e) { at.has(n) || at.set(n, new Map); const s = at.get(n); if (!s.has(t) && s.size !== 0) { console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`); return } s.set(t, e) }, get(n, t) { return at.has(n) && at.get(n).get(t) || null }, remove(n, t) { if (!at.has(n)) return; const e = at.get(n); e.delete(t), e.size === 0 && at.delete(n) } }, Vo = "5.1.3"; class G { constructor(t) { t = ut(t), t && (this._element = t, oe.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { oe.remove(this._element, this.constructor.DATA_KEY), d.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(t => { this[t] = null }) } _queueCallback(t, e, s = !0) { Wi(t, e, s) } static getInstance(t) { return oe.get(ut(t), this.DATA_KEY) } static getOrCreateInstance(t, e = {}) { return this.getInstance(t) || new this(t, typeof e == "object" ? e : null) } static get VERSION() { return Vo } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } } const Be = (n, t = "hide") => { const e = `click.dismiss${n.EVENT_KEY}`, s = n.NAME; d.on(document, e, `[data-bs-dismiss="${s}"]`, function (i) { if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), Ot(this)) return; const r = lt(this) || this.closest(`.${s}`); n.getOrCreateInstance(r)[t]() }) }, Uo = "alert", jo = "bs.alert", Qi = `.${jo}`, Fo = `close${Qi}`, Wo = `closed${Qi}`, Ko = "fade", Yo = "show"; class Ve extends G { static get NAME() { return Uo } close() { if (d.trigger(this._element, Fo).defaultPrevented) return; this._element.classList.remove(Yo); const e = this._element.classList.contains(Ko); this._queueCallback(() => this._destroyElement(), this._element, e) } _destroyElement() { this._element.remove(), d.trigger(this._element, Wo), this.dispose() } static jQueryInterface(t) { return this.each(function () { const e = Ve.getOrCreateInstance(this); if (typeof t == "string") { if (e[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); e[t](this) } }) } } Be(Ve, "close"); K(Ve); const qo = "button", zo = "bs.button", Go = `.${zo}`, Xo = ".data-api", Jo = "active", _s = '[data-bs-toggle="button"]', Qo = `click${Go}${Xo}`; class Ue extends G { static get NAME() { return qo } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle(Jo)) } static jQueryInterface(t) { return this.each(function () { const e = Ue.getOrCreateInstance(this); t === "toggle" && e[t]() }) } } d.on(document, Qo, _s, n => { n.preventDefault(); const t = n.target.closest(_s); Ue.getOrCreateInstance(t).toggle() }); K(Ue); function Es(n) { return n === "true" ? !0 : n === "false" ? !1 : n === Number(n).toString() ? Number(n) : n === "" || n === "null" ? null : n } function nn(n) { return n.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`) } const $ = { setDataAttribute(n, t, e) { n.setAttribute(`data-bs-${nn(t)}`, e) }, removeDataAttribute(n, t) { n.removeAttribute(`data-bs-${nn(t)}`) }, getDataAttributes(n) { if (!n) return {}; const t = {}; return Object.keys(n.dataset).filter(e => e.startsWith("bs")).forEach(e => { let s = e.replace(/^bs/, ""); s = s.charAt(0).toLowerCase() + s.slice(1, s.length), t[s] = Es(n.dataset[e]) }), t }, getDataAttribute(n, t) { return Es(n.getAttribute(`data-bs-${nn(t)}`)) }, offset(n) { const t = n.getBoundingClientRect(); return { top: t.top + window.pageYOffset, left: t.left + window.pageXOffset } }, position(n) { return { top: n.offsetTop, left: n.offsetLeft } } }, Zo = 3, g = { find(n, t = document.documentElement) { return [].concat(...Element.prototype.querySelectorAll.call(t, n)) }, findOne(n, t = document.documentElement) { return Element.prototype.querySelector.call(t, n) }, children(n, t) { return [].concat(...n.children).filter(e => e.matches(t)) }, parents(n, t) { const e = []; let s = n.parentNode; for (; s && s.nodeType === Node.ELEMENT_NODE && s.nodeType !== Zo;)s.matches(t) && e.push(s), s = s.parentNode; return e }, prev(n, t) { let e = n.previousElementSibling; for (; e;) { if (e.matches(t)) return [e]; e = e.previousElementSibling } return [] }, next(n, t) { let e = n.nextElementSibling; for (; e;) { if (e.matches(t)) return [e]; e = e.nextElementSibling } return [] }, focusableChildren(n) { const t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(e => `${e}:not([tabindex^="-"])`).join(", "); return this.find(t, n).filter(e => !Ot(e) && ue(e)) } }, gs = "carousel", ta = "bs.carousel", U = `.${ta}`, Zi = ".data-api", ea = "ArrowLeft", na = "ArrowRight", sa = 500, ia = 40, vs = { interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0 }, ra = { interval: "(number|boolean)", keyboard: "boolean", slide: "(boolean|string)", pause: "(string|boolean)", wrap: "boolean", touch: "boolean" }, vt = "next", bt = "prev", At = "left", se = "right", oa = { [ea]: se, [na]: At }, aa = `slide${U}`, bs = `slid${U}`, ca = `keydown${U}`, la = `mouseenter${U}`, ua = `mouseleave${U}`, fa = `touchstart${U}`, da = `touchmove${U}`, ha = `touchend${U}`, pa = `pointerdown${U}`, ma = `pointerup${U}`, _a = `dragstart${U}`, Ea = `load${U}${Zi}`, ga = `click${U}${Zi}`, va = "carousel", yt = "active", ba = "slide", ya = "carousel-item-end", Aa = "carousel-item-start", Ta = "carousel-item-next", wa = "carousel-item-prev", Oa = "pointer-event", Sa = ".active", ye = ".active.carousel-item", Na = ".carousel-item", Ca = ".carousel-item img", Da = ".carousel-item-next, .carousel-item-prev", La = ".carousel-indicators", Ra = "[data-bs-target]", $a = "[data-bs-slide], [data-bs-slide-to]", Ia = '[data-bs-ride="carousel"]', Pa = "touch", xa = "pen"; class nt extends G { constructor(t, e) { super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._indicatorsElement = g.findOne(La, this._element), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners() } static get Default() { return vs } static get NAME() { return gs } next() { this._slide(vt) } nextWhenVisible() { !document.hidden && ue(this._element) && this.next() } prev() { this._slide(bt) } pause(t) { t || (this._isPaused = !0), g.findOne(Da, this._element) && (Ui(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null } cycle(t) { t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval)) } to(t) { this._activeElement = g.findOne(ye, this._element); const e = this._getItemIndex(this._activeElement); if (t > this._items.length - 1 || t < 0) return; if (this._isSliding) { d.one(this._element, bs, () => this.to(t)); return } if (e === t) { this.pause(), this.cycle(); return } const s = t > e ? vt : bt; this._slide(s, this._items[t]) } _getConfig(t) { return t = { ...vs, ...$.getDataAttributes(this._element), ...typeof t == "object" ? t : {} }, et(gs, t, ra), t } _handleSwipe() { const t = Math.abs(this.touchDeltaX); if (t <= ia) return; const e = t / this.touchDeltaX; this.touchDeltaX = 0, e && this._slide(e > 0 ? se : At) } _addEventListeners() { this._config.keyboard && d.on(this._element, ca, t => this._keydown(t)), this._config.pause === "hover" && (d.on(this._element, la, t => this.pause(t)), d.on(this._element, ua, t => this.cycle(t))), this._config.touch && this._touchSupported && this._addTouchEventListeners() } _addTouchEventListeners() { const t = r => this._pointerEvent && (r.pointerType === xa || r.pointerType === Pa), e = r => { t(r) ? this.touchStartX = r.clientX : this._pointerEvent || (this.touchStartX = r.touches[0].clientX) }, s = r => { this.touchDeltaX = r.touches && r.touches.length > 1 ? 0 : r.touches[0].clientX - this.touchStartX }, i = r => { t(r) && (this.touchDeltaX = r.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(o => this.cycle(o), sa + this._config.interval)) }; g.find(Ca, this._element).forEach(r => { d.on(r, _a, o => o.preventDefault()) }), this._pointerEvent ? (d.on(this._element, pa, r => e(r)), d.on(this._element, ma, r => i(r)), this._element.classList.add(Oa)) : (d.on(this._element, fa, r => e(r)), d.on(this._element, da, r => s(r)), d.on(this._element, ha, r => i(r))) } _keydown(t) { if (/input|textarea/i.test(t.target.tagName)) return; const e = oa[t.key]; e && (t.preventDefault(), this._slide(e)) } _getItemIndex(t) { return this._items = t && t.parentNode ? g.find(Na, t.parentNode) : [], this._items.indexOf(t) } _getItemByOrder(t, e) { const s = t === vt; return Ki(this._items, e, s, this._config.wrap) } _triggerSlideEvent(t, e) { const s = this._getItemIndex(t), i = this._getItemIndex(g.findOne(ye, this._element)); return d.trigger(this._element, aa, { relatedTarget: t, direction: e, from: i, to: s }) } _setActiveIndicatorElement(t) { if (this._indicatorsElement) { const e = g.findOne(Sa, this._indicatorsElement); e.classList.remove(yt), e.removeAttribute("aria-current"); const s = g.find(Ra, this._indicatorsElement); for (let i = 0; i < s.length; i++)if (Number.parseInt(s[i].getAttribute("data-bs-slide-to"), 10) === this._getItemIndex(t)) { s[i].classList.add(yt), s[i].setAttribute("aria-current", "true"); break } } } _updateInterval() { const t = this._activeElement || g.findOne(ye, this._element); if (!t) return; const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10); e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval } _slide(t, e) { const s = this._directionToOrder(t), i = g.findOne(ye, this._element), r = this._getItemIndex(i), o = e || this._getItemByOrder(s, i), a = this._getItemIndex(o), c = Boolean(this._interval), l = s === vt, u = l ? Aa : ya, h = l ? Ta : wa, E = this._orderToDirection(s); if (o && o.classList.contains(yt)) { this._isSliding = !1; return } if (this._isSliding || this._triggerSlideEvent(o, E).defaultPrevented || !i || !o) return; this._isSliding = !0, c && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o; const p = () => { d.trigger(this._element, bs, { relatedTarget: o, direction: E, from: r, to: a }) }; if (this._element.classList.contains(ba)) { o.classList.add(h), Yt(o), i.classList.add(u), o.classList.add(u); const m = () => { o.classList.remove(u, h), o.classList.add(yt), i.classList.remove(yt, h, u), this._isSliding = !1, setTimeout(p, 0) }; this._queueCallback(m, i, !0) } else i.classList.remove(yt), o.classList.add(yt), this._isSliding = !1, p(); c && this.cycle() } _directionToOrder(t) { return [se, At].includes(t) ? k() ? t === At ? bt : vt : t === At ? vt : bt : t } _orderToDirection(t) { return [vt, bt].includes(t) ? k() ? t === bt ? At : se : t === bt ? se : At : t } static carouselInterface(t, e) { const s = nt.getOrCreateInstance(t, e); let { _config: i } = s; typeof e == "object" && (i = { ...i, ...e }); const r = typeof e == "string" ? e : i.slide; if (typeof e == "number") s.to(e); else if (typeof r == "string") { if (typeof s[r] > "u") throw new TypeError(`No method named "${r}"`); s[r]() } else i.interval && i.ride && (s.pause(), s.cycle()) } static jQueryInterface(t) { return this.each(function () { nt.carouselInterface(this, t) }) } static dataApiClickHandler(t) { const e = lt(this); if (!e || !e.classList.contains(va)) return; const s = { ...$.getDataAttributes(e), ...$.getDataAttributes(this) }, i = this.getAttribute("data-bs-slide-to"); i && (s.interval = !1), nt.carouselInterface(e, s), i && nt.getInstance(e).to(i), t.preventDefault() } } d.on(document, ga, $a, nt.dataApiClickHandler); d.on(window, Ea, () => { const n = g.find(Ia); for (let t = 0, e = n.length; t < e; t++)nt.carouselInterface(n[t], nt.getInstance(n[t])) }); K(nt); const ys = "collapse", tr = "bs.collapse", fe = `.${tr}`, Ma = ".data-api", As = { toggle: !0, parent: null }, ka = { toggle: "boolean", parent: "(null|element)" }, Ha = `show${fe}`, Ba = `shown${fe}`, Va = `hide${fe}`, Ua = `hidden${fe}`, ja = `click${fe}${Ma}`, sn = "show", Mt = "collapse", Ae = "collapsing", Ts = "collapsed", ws = `:scope .${Mt} .${Mt}`, Fa = "collapse-horizontal", Wa = "width", Ka = "height", Ya = ".collapse.show, .collapse.collapsing", vn = '[data-bs-toggle="collapse"]'; class kt extends G { constructor(t, e) { super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._triggerArray = []; const s = g.find(vn); for (let i = 0, r = s.length; i < r; i++) { const o = s[i], a = Un(o), c = g.find(a).filter(l => l === this._element); a !== null && c.length && (this._selector = a, this._triggerArray.push(o)) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return As } static get NAME() { return ys } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let t = [], e; if (this._config.parent) { const l = g.find(ws, this._config.parent); t = g.find(Ya, this._config.parent).filter(u => !l.includes(u)) } const s = g.findOne(this._selector); if (t.length) { const l = t.find(u => s !== u); if (e = l ? kt.getInstance(l) : null, e && e._isTransitioning) return } if (d.trigger(this._element, Ha).defaultPrevented) return; t.forEach(l => { s !== l && kt.getOrCreateInstance(l, { toggle: !1 }).hide(), e || oe.set(l, tr, null) }); const r = this._getDimension(); this._element.classList.remove(Mt), this._element.classList.add(Ae), this._element.style[r] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const o = () => { this._isTransitioning = !1, this._element.classList.remove(Ae), this._element.classList.add(Mt, sn), this._element.style[r] = "", d.trigger(this._element, Ba) }, c = `scroll${r[0].toUpperCase() + r.slice(1)}`; this._queueCallback(o, this._element, !0), this._element.style[r] = `${this._element[c]}px` } hide() { if (this._isTransitioning || !this._isShown() || d.trigger(this._element, Va).defaultPrevented) return; const e = this._getDimension(); this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Yt(this._element), this._element.classList.add(Ae), this._element.classList.remove(Mt, sn); const s = this._triggerArray.length; for (let r = 0; r < s; r++) { const o = this._triggerArray[r], a = lt(o); a && !this._isShown(a) && this._addAriaAndCollapsedClass([o], !1) } this._isTransitioning = !0; const i = () => { this._isTransitioning = !1, this._element.classList.remove(Ae), this._element.classList.add(Mt), d.trigger(this._element, Ua) }; this._element.style[e] = "", this._queueCallback(i, this._element, !0) } _isShown(t = this._element) { return t.classList.contains(sn) } _getConfig(t) { return t = { ...As, ...$.getDataAttributes(this._element), ...t }, t.toggle = Boolean(t.toggle), t.parent = ut(t.parent), et(ys, t, ka), t } _getDimension() { return this._element.classList.contains(Fa) ? Wa : Ka } _initializeChildren() { if (!this._config.parent) return; const t = g.find(ws, this._config.parent); g.find(vn, this._config.parent).filter(e => !t.includes(e)).forEach(e => { const s = lt(e); s && this._addAriaAndCollapsedClass([e], this._isShown(s)) }) } _addAriaAndCollapsedClass(t, e) { t.length && t.forEach(s => { e ? s.classList.remove(Ts) : s.classList.add(Ts), s.setAttribute("aria-expanded", e) }) } static jQueryInterface(t) { return this.each(function () { const e = {}; typeof t == "string" && /show|hide/.test(t) && (e.toggle = !1); const s = kt.getOrCreateInstance(this, e); if (typeof t == "string") { if (typeof s[t] > "u") throw new TypeError(`No method named "${t}"`); s[t]() } }) } } d.on(document, ja, vn, function (n) { (n.target.tagName === "A" || n.delegateTarget && n.delegateTarget.tagName === "A") && n.preventDefault(); const t = Un(this); g.find(t).forEach(s => { kt.getOrCreateInstance(s, { toggle: !1 }).toggle() }) }); K(kt); const rn = "dropdown", qa = "bs.dropdown", Lt = `.${qa}`, jn = ".data-api", Se = "Escape", Os = "Space", Ss = "Tab", bn = "ArrowUp", Ne = "ArrowDown", za = 2, Ga = new RegExp(`${bn}|${Ne}|${Se}`), Xa = `hide${Lt}`, Ja = `hidden${Lt}`, Qa = `show${Lt}`, Za = `shown${Lt}`, er = `click${Lt}${jn}`, nr = `keydown${Lt}${jn}`, tc = `keyup${Lt}${jn}`, It = "show", ec = "dropup", nc = "dropend", sc = "dropstart", ic = "navbar", ae = '[data-bs-toggle="dropdown"]', yn = ".dropdown-menu", rc = ".navbar-nav", oc = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", ac = k() ? "top-end" : "top-start", cc = k() ? "top-start" : "top-end", lc = k() ? "bottom-end" : "bottom-start", uc = k() ? "bottom-start" : "bottom-end", fc = k() ? "left-start" : "right-start", dc = k() ? "right-start" : "left-start", hc = { offset: [0, 2], boundary: "clippingParents", reference: "toggle", display: "dynamic", popperConfig: null, autoClose: !0 }, pc = { offset: "(array|string|function)", boundary: "(string|element)", reference: "(string|element|object)", display: "string", popperConfig: "(null|object|function)", autoClose: "(boolean|string)" }; class j extends G { constructor(t, e) { super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar() } static get Default() { return hc } static get DefaultType() { return pc } static get NAME() { return rn } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (Ot(this._element) || this._isShown(this._menu)) return; const t = { relatedTarget: this._element }; if (d.trigger(this._element, Qa, t).defaultPrevented) return; const s = j.getParentFromElement(this._element); this._inNavbar ? $.setDataAttribute(this._menu, "popper", "none") : this._createPopper(s), "ontouchstart" in document.documentElement && !s.closest(rc) && [].concat(...document.body.children).forEach(i => d.on(i, "mouseover", Ie)), this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(It), this._element.classList.add(It), d.trigger(this._element, Za, t) } hide() { if (Ot(this._element) || !this._isShown(this._menu)) return; const t = { relatedTarget: this._element }; this._completeHide(t) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(t) { d.trigger(this._element, Xa, t).defaultPrevented || ("ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(s => d.off(s, "mouseover", Ie)), this._popper && this._popper.destroy(), this._menu.classList.remove(It), this._element.classList.remove(It), this._element.setAttribute("aria-expanded", "false"), $.removeDataAttribute(this._menu, "popper"), d.trigger(this._element, Ja, t)) } _getConfig(t) { if (t = { ...this.constructor.Default, ...$.getDataAttributes(this._element), ...t }, et(rn, t, this.constructor.DefaultType), typeof t.reference == "object" && !Ct(t.reference) && typeof t.reference.getBoundingClientRect != "function") throw new TypeError(`${rn.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return t } _createPopper(t) { if (typeof Bi > "u") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; this._config.reference === "parent" ? e = t : Ct(this._config.reference) ? e = ut(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference); const s = this._getPopperConfig(), i = s.modifiers.find(r => r.name === "applyStyles" && r.enabled === !1); this._popper = Vn(e, this._menu, s), i && $.setDataAttribute(this._menu, "popper", "static") } _isShown(t = this._element) { return t.classList.contains(It) } _getMenuElement() { return g.next(this._element, yn)[0] } _getPlacement() { const t = this._element.parentNode; if (t.classList.contains(nc)) return fc; if (t.classList.contains(sc)) return dc; const e = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end"; return t.classList.contains(ec) ? e ? cc : ac : e ? uc : lc } _detectNavbar() { return this._element.closest(`.${ic}`) !== null } _getOffset() { const { offset: t } = this._config; return typeof t == "string" ? t.split(",").map(e => Number.parseInt(e, 10)) : typeof t == "function" ? e => t(e, this._element) : t } _getPopperConfig() { const t = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return this._config.display === "static" && (t.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...t, ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig } } _selectMenuItem({ key: t, target: e }) { const s = g.find(oc, this._menu).filter(ue); s.length && Ki(s, e, t === Ne, !s.includes(e)).focus() } static jQueryInterface(t) { return this.each(function () { const e = j.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof e[t] > "u") throw new TypeError(`No method named "${t}"`); e[t]() } }) } static clearMenus(t) { if (t && (t.button === za || t.type === "keyup" && t.key !== Ss)) return; const e = g.find(ae); for (let s = 0, i = e.length; s < i; s++) { const r = j.getInstance(e[s]); if (!r || r._config.autoClose === !1 || !r._isShown()) continue; const o = { relatedTarget: r._element }; if (t) { const a = t.composedPath(), c = a.includes(r._menu); if (a.includes(r._element) || r._config.autoClose === "inside" && !c || r._config.autoClose === "outside" && c || r._menu.contains(t.target) && (t.type === "keyup" && t.key === Ss || /input|select|option|textarea|form/i.test(t.target.tagName))) continue; t.type === "click" && (o.clickEvent = t) } r._completeHide(o) } } static getParentFromElement(t) { return lt(t) || t.parentNode } static dataApiKeydownHandler(t) { if (/input|textarea/i.test(t.target.tagName) ? t.key === Os || t.key !== Se && (t.key !== Ne && t.key !== bn || t.target.closest(yn)) : !Ga.test(t.key)) return; const e = this.classList.contains(It); if (!e && t.key === Se || (t.preventDefault(), t.stopPropagation(), Ot(this))) return; const s = this.matches(ae) ? this : g.prev(this, ae)[0], i = j.getOrCreateInstance(s); if (t.key === Se) { i.hide(); return } if (t.key === bn || t.key === Ne) { e || i.show(), i._selectMenuItem(t); return } (!e || t.key === Os) && j.clearMenus() } } d.on(document, nr, ae, j.dataApiKeydownHandler); d.on(document, nr, yn, j.dataApiKeydownHandler); d.on(document, er, j.clearMenus); d.on(document, tc, j.clearMenus); d.on(document, er, ae, function (n) { n.preventDefault(), j.getOrCreateInstance(this).toggle() }); K(j); const Ns = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Cs = ".sticky-top"; class An { constructor() { this._element = document.body } getWidth() { const t = document.documentElement.clientWidth; return Math.abs(window.innerWidth - t) } hide() { const t = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, "paddingRight", e => e + t), this._setElementAttributes(Ns, "paddingRight", e => e + t), this._setElementAttributes(Cs, "marginRight", e => e - t) } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(t, e, s) { const i = this.getWidth(), r = o => { if (o !== this._element && window.innerWidth > o.clientWidth + i) return; this._saveInitialAttribute(o, e); const a = window.getComputedStyle(o)[e]; o.style[e] = `${s(Number.parseFloat(a))}px` }; this._applyManipulationCallback(t, r) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, "paddingRight"), this._resetElementAttributes(Ns, "paddingRight"), this._resetElementAttributes(Cs, "marginRight") } _saveInitialAttribute(t, e) { const s = t.style[e]; s && $.setDataAttribute(t, e, s) } _resetElementAttributes(t, e) { const s = i => { const r = $.getDataAttribute(i, e); typeof r > "u" ? i.style.removeProperty(e) : ($.removeDataAttribute(i, e), i.style[e] = r) }; this._applyManipulationCallback(t, s) } _applyManipulationCallback(t, e) { Ct(t) ? e(t) : g.find(t, this._element).forEach(e) } isOverflowing() { return this.getWidth() > 0 } } const mc = { className: "modal-backdrop", isVisible: !0, isAnimated: !1, rootElement: "body", clickCallback: null }, _c = { className: "string", isVisible: "boolean", isAnimated: "boolean", rootElement: "(element|string)", clickCallback: "(function|null)" }, sr = "backdrop", Ec = "fade", Ds = "show", Ls = `mousedown.bs.${sr}`; class ir { constructor(t) { this._config = this._getConfig(t), this._isAppended = !1, this._element = null } show(t) { if (!this._config.isVisible) { Tt(t); return } this._append(), this._config.isAnimated && Yt(this._getElement()), this._getElement().classList.add(Ds), this._emulateAnimation(() => { Tt(t) }) } hide(t) { if (!this._config.isVisible) { Tt(t); return } this._getElement().classList.remove(Ds), this._emulateAnimation(() => { this.dispose(), Tt(t) }) } _getElement() { if (!this._element) { const t = document.createElement("div"); t.className = this._config.className, this._config.isAnimated && t.classList.add(Ec), this._element = t } return this._element } _getConfig(t) { return t = { ...mc, ...typeof t == "object" ? t : {} }, t.rootElement = ut(t.rootElement), et(sr, t, _c), t } _append() { this._isAppended || (this._config.rootElement.append(this._getElement()), d.on(this._getElement(), Ls, () => { Tt(this._config.clickCallback) }), this._isAppended = !0) } dispose() { this._isAppended && (d.off(this._element, Ls), this._element.remove(), this._isAppended = !1) } _emulateAnimation(t) { Wi(t, this._getElement(), this._config.isAnimated) } } const gc = { trapElement: null, autofocus: !0 }, vc = { trapElement: "element", autofocus: "boolean" }, bc = "focustrap", yc = "bs.focustrap", Pe = `.${yc}`, Ac = `focusin${Pe}`, Tc = `keydown.tab${Pe}`, wc = "Tab", Oc = "forward", Rs = "backward"; class rr { constructor(t) { this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null } activate() { const { trapElement: t, autofocus: e } = this._config; this._isActive || (e && t.focus(), d.off(document, Pe), d.on(document, Ac, s => this._handleFocusin(s)), d.on(document, Tc, s => this._handleKeydown(s)), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, d.off(document, Pe)) } _handleFocusin(t) { const { target: e } = t, { trapElement: s } = this._config; if (e === document || e === s || s.contains(e)) return; const i = g.focusableChildren(s); i.length === 0 ? s.focus() : this._lastTabNavDirection === Rs ? i[i.length - 1].focus() : i[0].focus() } _handleKeydown(t) { t.key === wc && (this._lastTabNavDirection = t.shiftKey ? Rs : Oc) } _getConfig(t) { return t = { ...gc, ...typeof t == "object" ? t : {} }, et(bc, t, vc), t } } const $s = "modal", Sc = "bs.modal", Y = `.${Sc}`, Nc = ".data-api", Is = "Escape", Ps = { backdrop: !0, keyboard: !0, focus: !0 }, Cc = { backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean" }, Dc = `hide${Y}`, Lc = `hidePrevented${Y}`, or = `hidden${Y}`, ar = `show${Y}`, Rc = `shown${Y}`, xs = `resize${Y}`, Ms = `click.dismiss${Y}`, ks = `keydown.dismiss${Y}`, $c = `mouseup.dismiss${Y}`, Hs = `mousedown.dismiss${Y}`, Ic = `click${Y}${Nc}`, Bs = "modal-open", Pc = "fade", Vs = "show", on = "modal-static", xc = ".modal.show", Mc = ".modal-dialog", kc = ".modal-body", Hc = '[data-bs-toggle="modal"]'; class Ft extends G { constructor(t, e) { super(t), this._config = this._getConfig(e), this._dialog = g.findOne(Mc, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new An } static get Default() { return Ps } static get NAME() { return $s } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { this._isShown || this._isTransitioning || d.trigger(this._element, ar, { relatedTarget: t }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add(Bs), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), d.on(this._dialog, Hs, () => { d.one(this._element, $c, s => { s.target === this._element && (this._ignoreBackdropClick = !0) }) }), this._showBackdrop(() => this._showElement(t))) } hide() { if (!this._isShown || this._isTransitioning || d.trigger(this._element, Dc).defaultPrevented) return; this._isShown = !1; const e = this._isAnimated(); e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove(Vs), d.off(this._element, Ms), d.off(this._dialog, Hs), this._queueCallback(() => this._hideModal(), this._element, e) } dispose() { [window, this._dialog].forEach(t => d.off(t, Y)), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new ir({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new rr({ trapElement: this._element }) } _getConfig(t) { return t = { ...Ps, ...$.getDataAttributes(this._element), ...typeof t == "object" ? t : {} }, et($s, t, Cc), t } _showElement(t) { const e = this._isAnimated(), s = g.findOne(kc, this._dialog); (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0, s && (s.scrollTop = 0), e && Yt(this._element), this._element.classList.add(Vs); const i = () => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, d.trigger(this._element, Rc, { relatedTarget: t }) }; this._queueCallback(i, this._dialog, e) } _setEscapeEvent() { this._isShown ? d.on(this._element, ks, t => { this._config.keyboard && t.key === Is ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === Is && this._triggerBackdropTransition() }) : d.off(this._element, ks) } _setResizeEvent() { this._isShown ? d.on(window, xs, () => this._adjustDialog()) : d.off(window, xs) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove(Bs), this._resetAdjustments(), this._scrollBar.reset(), d.trigger(this._element, or) }) } _showBackdrop(t) { d.on(this._element, Ms, e => { if (this._ignoreBackdropClick) { this._ignoreBackdropClick = !1; return } e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === "static" && this._triggerBackdropTransition()) }), this._backdrop.show(t) } _isAnimated() { return this._element.classList.contains(Pc) } _triggerBackdropTransition() { if (d.trigger(this._element, Lc).defaultPrevented) return; const { classList: e, scrollHeight: s, style: i } = this._element, r = s > document.documentElement.clientHeight; !r && i.overflowY === "hidden" || e.contains(on) || (r || (i.overflowY = "hidden"), e.add(on), this._queueCallback(() => { e.remove(on), r || this._queueCallback(() => { i.overflowY = "" }, this._dialog) }, this._dialog), this._element.focus()) } _adjustDialog() { const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), s = e > 0; (!s && t && !k() || s && !t && k()) && (this._element.style.paddingLeft = `${e}px`), (s && !t && !k() || !s && t && k()) && (this._element.style.paddingRight = `${e}px`) } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(t, e) { return this.each(function () { const s = Ft.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof s[t] > "u") throw new TypeError(`No method named "${t}"`); s[t](e) } }) } } d.on(document, Ic, Hc, function (n) { const t = lt(this);["A", "AREA"].includes(this.tagName) && n.preventDefault(), d.one(t, ar, i => { i.defaultPrevented || d.one(t, or, () => { ue(this) && this.focus() }) }); const e = g.findOne(xc); e && Ft.getInstance(e).hide(), Ft.getOrCreateInstance(t).toggle(this) }); Be(Ft); K(Ft); const Us = "offcanvas", Bc = "bs.offcanvas", Rt = `.${Bc}`, cr = ".data-api", Vc = `load${Rt}${cr}`, Uc = "Escape", js = { backdrop: !0, keyboard: !0, scroll: !1 }, jc = { backdrop: "boolean", keyboard: "boolean", scroll: "boolean" }, Fs = "show", Fc = "offcanvas-backdrop", lr = ".offcanvas.show", Wc = `show${Rt}`, Kc = `shown${Rt}`, Yc = `hide${Rt}`, ur = `hidden${Rt}`, qc = `click${Rt}${cr}`, zc = `keydown.dismiss${Rt}`, Gc = '[data-bs-toggle="offcanvas"]'; class Dt extends G { constructor(t, e) { super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get NAME() { return Us } static get Default() { return js } toggle(t) { return this._isShown ? this.hide() : this.show(t) } show(t) { if (this._isShown || d.trigger(this._element, Wc, { relatedTarget: t }).defaultPrevented) return; this._isShown = !0, this._element.style.visibility = "visible", this._backdrop.show(), this._config.scroll || new An().hide(), this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Fs); const s = () => { this._config.scroll || this._focustrap.activate(), d.trigger(this._element, Kc, { relatedTarget: t }) }; this._queueCallback(s, this._element, !0) } hide() { if (!this._isShown || d.trigger(this._element, Yc).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove(Fs), this._backdrop.hide(); const e = () => { this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._element.style.visibility = "hidden", this._config.scroll || new An().reset(), d.trigger(this._element, ur) }; this._queueCallback(e, this._element, !0) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _getConfig(t) { return t = { ...js, ...$.getDataAttributes(this._element), ...typeof t == "object" ? t : {} }, et(Us, t, jc), t } _initializeBackDrop() { return new ir({ className: Fc, isVisible: this._config.backdrop, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: () => this.hide() }) } _initializeFocusTrap() { return new rr({ trapElement: this._element }) } _addEventListeners() { d.on(this._element, zc, t => { this._config.keyboard && t.key === Uc && this.hide() }) } static jQueryInterface(t) { return this.each(function () { const e = Dt.getOrCreateInstance(this, t); if (typeof t == "string") { if (e[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`); e[t](this) } }) } } d.on(document, qc, Gc, function (n) { const t = lt(this); if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), Ot(this)) return; d.one(t, ur, () => { ue(this) && this.focus() }); const e = g.findOne(lr); e && e !== t && Dt.getInstance(e).hide(), Dt.getOrCreateInstance(t).toggle(this) }); d.on(window, Vc, () => g.find(lr).forEach(n => Dt.getOrCreateInstance(n).show())); Be(Dt); K(Dt); const Xc = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Jc = /^aria-[\w-]*$/i, Qc = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Zc = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, tl = (n, t) => { const e = n.nodeName.toLowerCase(); if (t.includes(e)) return Xc.has(e) ? Boolean(Qc.test(n.nodeValue) || Zc.test(n.nodeValue)) : !0; const s = t.filter(i => i instanceof RegExp); for (let i = 0, r = s.length; i < r; i++)if (s[i].test(e)) return !0; return !1 }, el = { "*": ["class", "dir", "id", "lang", "role", Jc], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }; function Ws(n, t, e) { if (!n.length) return n; if (e && typeof e == "function") return e(n); const i = new window.DOMParser().parseFromString(n, "text/html"), r = [].concat(...i.body.querySelectorAll("*")); for (let o = 0, a = r.length; o < a; o++) { const c = r[o], l = c.nodeName.toLowerCase(); if (!Object.keys(t).includes(l)) { c.remove(); continue } const u = [].concat(...c.attributes), h = [].concat(t["*"] || [], t[l] || []); u.forEach(E => { tl(E, h) || c.removeAttribute(E.nodeName) }) } return i.body.innerHTML } const Ks = "tooltip", nl = "bs.tooltip", X = `.${nl}`, sl = "bs-tooltip", il = new Set(["sanitize", "allowList", "sanitizeFn"]), rl = { animation: "boolean", template: "string", title: "(string|element|function)", trigger: "string", delay: "(number|object)", html: "boolean", selector: "(string|boolean)", placement: "(string|function)", offset: "(array|string|function)", container: "(string|element|boolean)", fallbackPlacements: "array", boundary: "(string|element)", customClass: "(string|function)", sanitize: "boolean", sanitizeFn: "(null|function)", allowList: "object", popperConfig: "(null|object|function)" }, ol = { AUTO: "auto", TOP: "top", RIGHT: k() ? "left" : "right", BOTTOM: "bottom", LEFT: k() ? "right" : "left" }, al = { animation: !0, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', trigger: "hover focus", title: "", delay: 0, html: !1, selector: !1, placement: "top", offset: [0, 0], container: !1, fallbackPlacements: ["top", "right", "bottom", "left"], boundary: "clippingParents", customClass: "", sanitize: !0, sanitizeFn: null, allowList: el, popperConfig: null }, cl = { HIDE: `hide${X}`, HIDDEN: `hidden${X}`, SHOW: `show${X}`, SHOWN: `shown${X}`, INSERTED: `inserted${X}`, CLICK: `click${X}`, FOCUSIN: `focusin${X}`, FOCUSOUT: `focusout${X}`, MOUSEENTER: `mouseenter${X}`, MOUSELEAVE: `mouseleave${X}` }, Te = "fade", ll = "modal", Jt = "show", Qt = "show", an = "out", Ys = ".tooltip-inner", qs = `.${ll}`, zs = "hide.bs.modal", Zt = "hover", cn = "focus", ul = "click", fl = "manual"; class qt extends G { constructor(t, e) { if (typeof Bi > "u") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners() } static get Default() { return al } static get NAME() { return Ks } static get Event() { return cl } static get DefaultType() { return rl } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle(t) { if (this._isEnabled) if (t) { const e = this._initializeOnDelegatedTarget(t); e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e) } else { if (this.getTipElement().classList.contains(Jt)) { this._leave(null, this); return } this._enter(null, this) } } dispose() { clearTimeout(this._timeout), d.off(this._element.closest(qs), zs, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose() } show() { if (this._element.style.display === "none") throw new Error("Please use show on visible elements"); if (!(this.isWithContent() && this._isEnabled)) return; const t = d.trigger(this._element, this.constructor.Event.SHOW), e = ji(this._element), s = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element); if (t.defaultPrevented || !s) return; this.constructor.NAME === "tooltip" && this.tip && this.getTitle() !== this.tip.querySelector(Ys).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null); const i = this.getTipElement(), r = Do(this.constructor.NAME); i.setAttribute("id", r), this._element.setAttribute("aria-describedby", r), this._config.animation && i.classList.add(Te); const o = typeof this._config.placement == "function" ? this._config.placement.call(this, i, this._element) : this._config.placement, a = this._getAttachment(o); this._addAttachmentClass(a); const { container: c } = this._config; oe.set(i, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (c.append(i), d.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Vn(this._element, i, this._getPopperConfig(a)), i.classList.add(Jt); const l = this._resolvePossibleFunction(this._config.customClass); l && i.classList.add(...l.split(" ")), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(E => { d.on(E, "mouseover", Ie) }); const u = () => { const E = this._hoverState; this._hoverState = null, d.trigger(this._element, this.constructor.Event.SHOWN), E === an && this._leave(null, this) }, h = this.tip.classList.contains(Te); this._queueCallback(u, this.tip, h) } hide() { if (!this._popper) return; const t = this.getTipElement(), e = () => { this._isWithActiveTrigger() || (this._hoverState !== Qt && t.remove(), this._cleanTipClass(), this._element.removeAttribute("aria-describedby"), d.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper()) }; if (d.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return; t.classList.remove(Jt), "ontouchstart" in document.documentElement && [].concat(...document.body.children).forEach(r => d.off(r, "mouseover", Ie)), this._activeTrigger[ul] = !1, this._activeTrigger[cn] = !1, this._activeTrigger[Zt] = !1; const i = this.tip.classList.contains(Te); this._queueCallback(e, this.tip, i), this._hoverState = "" } update() { this._popper !== null && this._popper.update() } isWithContent() { return Boolean(this.getTitle()) } getTipElement() { if (this.tip) return this.tip; const t = document.createElement("div"); t.innerHTML = this._config.template; const e = t.children[0]; return this.setContent(e), e.classList.remove(Te, Jt), this.tip = e, this.tip } setContent(t) { this._sanitizeAndSetContent(t, this.getTitle(), Ys) } _sanitizeAndSetContent(t, e, s) { const i = g.findOne(s, t); if (!e && i) { i.remove(); return } this.setElementContent(i, e) } setElementContent(t, e) { if (t !== null) { if (Ct(e)) { e = ut(e), this._config.html ? e.parentNode !== t && (t.innerHTML = "", t.append(e)) : t.textContent = e.textContent; return } this._config.html ? (this._config.sanitize && (e = Ws(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e } } getTitle() { const t = this._element.getAttribute("data-bs-original-title") || this._config.title; return this._resolvePossibleFunction(t) } updateAttachment(t) { return t === "right" ? "end" : t === "left" ? "start" : t } _initializeOnDelegatedTarget(t, e) { return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig()) } _getOffset() { const { offset: t } = this._config; return typeof t == "string" ? t.split(",").map(e => Number.parseInt(e, 10)) : typeof t == "function" ? e => t(e, this._element) : t } _resolvePossibleFunction(t) { return typeof t == "function" ? t.call(this._element) : t } _getPopperConfig(t) { const e = { placement: t, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "onChange", enabled: !0, phase: "afterWrite", fn: s => this._handlePopperPlacementChange(s) }], onFirstUpdate: s => { s.options.placement !== s.placement && this._handlePopperPlacementChange(s) } }; return { ...e, ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(e) : this._config.popperConfig } } _addAttachmentClass(t) { this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`) } _getAttachment(t) { return ol[t.toUpperCase()] } _setListeners() { this._config.trigger.split(" ").forEach(e => { if (e === "click") d.on(this._element, this.constructor.Event.CLICK, this._config.selector, s => this.toggle(s)); else if (e !== fl) { const s = e === Zt ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, i = e === Zt ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT; d.on(this._element, s, this._config.selector, r => this._enter(r)), d.on(this._element, i, this._config.selector, r => this._leave(r)) } }), this._hideModalHandler = () => { this._element && this.hide() }, d.on(this._element.closest(qs), zs, this._hideModalHandler), this._config.selector ? this._config = { ...this._config, trigger: "manual", selector: "" } : this._fixTitle() } _fixTitle() { const t = this._element.getAttribute("title"), e = typeof this._element.getAttribute("data-bs-original-title"); (t || e !== "string") && (this._element.setAttribute("data-bs-original-title", t || ""), t && !this._element.getAttribute("aria-label") && !this._element.textContent && this._element.setAttribute("aria-label", t), this._element.setAttribute("title", "")) } _enter(t, e) { if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusin" ? cn : Zt] = !0), e.getTipElement().classList.contains(Jt) || e._hoverState === Qt) { e._hoverState = Qt; return } if (clearTimeout(e._timeout), e._hoverState = Qt, !e._config.delay || !e._config.delay.show) { e.show(); return } e._timeout = setTimeout(() => { e._hoverState === Qt && e.show() }, e._config.delay.show) } _leave(t, e) { if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === "focusout" ? cn : Zt] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) { if (clearTimeout(e._timeout), e._hoverState = an, !e._config.delay || !e._config.delay.hide) { e.hide(); return } e._timeout = setTimeout(() => { e._hoverState === an && e.hide() }, e._config.delay.hide) } } _isWithActiveTrigger() { for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0; return !1 } _getConfig(t) { const e = $.getDataAttributes(this._element); return Object.keys(e).forEach(s => { il.has(s) && delete e[s] }), t = { ...this.constructor.Default, ...e, ...typeof t == "object" && t ? t : {} }, t.container = t.container === !1 ? document.body : ut(t.container), typeof t.delay == "number" && (t.delay = { show: t.delay, hide: t.delay }), typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), et(Ks, t, this.constructor.DefaultType), t.sanitize && (t.template = Ws(t.template, t.allowList, t.sanitizeFn)), t } _getDelegateConfig() { const t = {}; for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]); return t } _cleanTipClass() { const t = this.getTipElement(), e = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, "g"), s = t.getAttribute("class").match(e); s !== null && s.length > 0 && s.map(i => i.trim()).forEach(i => t.classList.remove(i)) } _getBasicClassPrefix() { return sl } _handlePopperPlacementChange(t) { const { state: e } = t; e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement))) } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null) } static jQueryInterface(t) { return this.each(function () { const e = qt.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof e[t] > "u") throw new TypeError(`No method named "${t}"`); e[t]() } }) } } K(qt); const dl = "popover", hl = "bs.popover", J = `.${hl}`, pl = "bs-popover", ml = { ...qt.Default, placement: "right", offset: [0, 8], trigger: "click", content: "", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>' }, _l = { ...qt.DefaultType, content: "(string|element|function)" }, El = { HIDE: `hide${J}`, HIDDEN: `hidden${J}`, SHOW: `show${J}`, SHOWN: `shown${J}`, INSERTED: `inserted${J}`, CLICK: `click${J}`, FOCUSIN: `focusin${J}`, FOCUSOUT: `focusout${J}`, MOUSEENTER: `mouseenter${J}`, MOUSELEAVE: `mouseleave${J}` }, gl = ".popover-header", vl = ".popover-body"; class Fn extends qt { static get Default() { return ml } static get NAME() { return dl } static get Event() { return El } static get DefaultType() { return _l } isWithContent() { return this.getTitle() || this._getContent() } setContent(t) { this._sanitizeAndSetContent(t, this.getTitle(), gl), this._sanitizeAndSetContent(t, this._getContent(), vl) } _getContent() { return this._resolvePossibleFunction(this._config.content) } _getBasicClassPrefix() { return pl } static jQueryInterface(t) { return this.each(function () { const e = Fn.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof e[t] > "u") throw new TypeError(`No method named "${t}"`); e[t]() } }) } } K(Fn); const Gs = "scrollspy", bl = "bs.scrollspy", je = `.${bl}`, yl = ".data-api", Xs = { offset: 10, method: "auto", target: "" }, Al = { offset: "number", method: "string", target: "(string|element)" }, Tl = `activate${je}`, wl = `scroll${je}`, Ol = `load${je}${yl}`, fr = "dropdown-item", Pt = "active", Sl = '[data-bs-spy="scroll"]', Nl = ".nav, .list-group", Tn = ".nav-link", Cl = ".nav-item", dr = ".list-group-item", ln = `${Tn}, ${dr}, .${fr}`, Dl = ".dropdown", Ll = ".dropdown-toggle", Rl = "offset", Js = "position"; class Fe extends G { constructor(t, e) { super(t), this._scrollElement = this._element.tagName === "BODY" ? window : this._element, this._config = this._getConfig(e), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, d.on(this._scrollElement, wl, () => this._process()), this.refresh(), this._process() } static get Default() { return Xs } static get NAME() { return Gs } refresh() { const t = this._scrollElement === this._scrollElement.window ? Rl : Js, e = this._config.method === "auto" ? t : this._config.method, s = e === Js ? this._getScrollTop() : 0; this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), g.find(ln, this._config.target).map(r => { const o = Un(r), a = o ? g.findOne(o) : null; if (a) { const c = a.getBoundingClientRect(); if (c.width || c.height) return [$[e](a).top + s, o] } return null }).filter(r => r).sort((r, o) => r[0] - o[0]).forEach(r => { this._offsets.push(r[0]), this._targets.push(r[1]) }) } dispose() { d.off(this._scrollElement, je), super.dispose() } _getConfig(t) { return t = { ...Xs, ...$.getDataAttributes(this._element), ...typeof t == "object" && t ? t : {} }, t.target = ut(t.target) || document.documentElement, et(Gs, t, Al), t } _getScrollTop() { return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop } _getScrollHeight() { return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight) } _getOffsetHeight() { return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height } _process() { const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), s = this._config.offset + e - this._getOffsetHeight(); if (this._scrollHeight !== e && this.refresh(), t >= s) { const i = this._targets[this._targets.length - 1]; this._activeTarget !== i && this._activate(i); return } if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) { this._activeTarget = null, this._clear(); return } for (let i = this._offsets.length; i--;)this._activeTarget !== this._targets[i] && t >= this._offsets[i] && (typeof this._offsets[i + 1] > "u" || t < this._offsets[i + 1]) && this._activate(this._targets[i]) } _activate(t) { this._activeTarget = t, this._clear(); const e = ln.split(",").map(i => `${i}[data-bs-target="${t}"],${i}[href="${t}"]`), s = g.findOne(e.join(","), this._config.target); s.classList.add(Pt), s.classList.contains(fr) ? g.findOne(Ll, s.closest(Dl)).classList.add(Pt) : g.parents(s, Nl).forEach(i => { g.prev(i, `${Tn}, ${dr}`).forEach(r => r.classList.add(Pt)), g.prev(i, Cl).forEach(r => { g.children(r, Tn).forEach(o => o.classList.add(Pt)) }) }), d.trigger(this._scrollElement, Tl, { relatedTarget: t }) } _clear() { g.find(ln, this._config.target).filter(t => t.classList.contains(Pt)).forEach(t => t.classList.remove(Pt)) } static jQueryInterface(t) { return this.each(function () { const e = Fe.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof e[t] > "u") throw new TypeError(`No method named "${t}"`); e[t]() } }) } } d.on(window, Ol, () => { g.find(Sl).forEach(n => new Fe(n)) }); K(Fe); const $l = "tab", Il = "bs.tab", de = `.${Il}`, Pl = ".data-api", xl = `hide${de}`, Ml = `hidden${de}`, kl = `show${de}`, Hl = `shown${de}`, Bl = `click${de}${Pl}`, Vl = "dropdown-menu", te = "active", Qs = "fade", Zs = "show", Ul = ".dropdown", jl = ".nav, .list-group", ti = ".active", ei = ":scope > li > .active", Fl = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', Wl = ".dropdown-toggle", Kl = ":scope > .dropdown-menu .active"; class We extends G { static get NAME() { return $l } show() { if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(te)) return; let t; const e = lt(this._element), s = this._element.closest(jl); if (s) { const a = s.nodeName === "UL" || s.nodeName === "OL" ? ei : ti; t = g.find(a, s), t = t[t.length - 1] } const i = t ? d.trigger(t, xl, { relatedTarget: this._element }) : null; if (d.trigger(this._element, kl, { relatedTarget: t }).defaultPrevented || i !== null && i.defaultPrevented) return; this._activate(this._element, s); const o = () => { d.trigger(t, Ml, { relatedTarget: this._element }), d.trigger(this._element, Hl, { relatedTarget: t }) }; e ? this._activate(e, e.parentNode, o) : o() } _activate(t, e, s) { const r = (e && (e.nodeName === "UL" || e.nodeName === "OL") ? g.find(ei, e) : g.children(e, ti))[0], o = s && r && r.classList.contains(Qs), a = () => this._transitionComplete(t, r, s); r && o ? (r.classList.remove(Zs), this._queueCallback(a, t, !0)) : a() } _transitionComplete(t, e, s) { if (e) { e.classList.remove(te); const r = g.findOne(Kl, e.parentNode); r && r.classList.remove(te), e.getAttribute("role") === "tab" && e.setAttribute("aria-selected", !1) } t.classList.add(te), t.getAttribute("role") === "tab" && t.setAttribute("aria-selected", !0), Yt(t), t.classList.contains(Qs) && t.classList.add(Zs); let i = t.parentNode; if (i && i.nodeName === "LI" && (i = i.parentNode), i && i.classList.contains(Vl)) { const r = t.closest(Ul); r && g.find(Wl, r).forEach(o => o.classList.add(te)), t.setAttribute("aria-expanded", !0) } s && s() } static jQueryInterface(t) { return this.each(function () { const e = We.getOrCreateInstance(this); if (typeof t == "string") { if (typeof e[t] > "u") throw new TypeError(`No method named "${t}"`); e[t]() } }) } } d.on(document, Bl, Fl, function (n) { if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), Ot(this)) return; We.getOrCreateInstance(this).show() }); K(We); const ni = "toast", Yl = "bs.toast", ht = `.${Yl}`, ql = `mouseover${ht}`, zl = `mouseout${ht}`, Gl = `focusin${ht}`, Xl = `focusout${ht}`, Jl = `hide${ht}`, Ql = `hidden${ht}`, Zl = `show${ht}`, tu = `shown${ht}`, eu = "fade", si = "hide", ee = "show", we = "showing", nu = { animation: "boolean", autohide: "boolean", delay: "number" }, ii = { animation: !0, autohide: !0, delay: 5e3 }; class Ke extends G { constructor(t, e) { super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get DefaultType() { return nu } static get Default() { return ii } static get NAME() { return ni } show() { if (d.trigger(this._element, Zl).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add(eu); const e = () => { this._element.classList.remove(we), d.trigger(this._element, tu), this._maybeScheduleHide() }; this._element.classList.remove(si), Yt(this._element), this._element.classList.add(ee), this._element.classList.add(we), this._queueCallback(e, this._element, this._config.animation) } hide() { if (!this._element.classList.contains(ee) || d.trigger(this._element, Jl).defaultPrevented) return; const e = () => { this._element.classList.add(si), this._element.classList.remove(we), this._element.classList.remove(ee), d.trigger(this._element, Ql) }; this._element.classList.add(we), this._queueCallback(e, this._element, this._config.animation) } dispose() { this._clearTimeout(), this._element.classList.contains(ee) && this._element.classList.remove(ee), super.dispose() } _getConfig(t) { return t = { ...ii, ...$.getDataAttributes(this._element), ...typeof t == "object" && t ? t : {} }, et(ni, t, this.constructor.DefaultType), t } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide() }, this._config.delay))) } _onInteraction(t, e) { switch (t.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = e; break; case "focusin": case "focusout": this._hasKeyboardInteraction = e; break }if (e) { this._clearTimeout(); return } const s = t.relatedTarget; this._element === s || this._element.contains(s) || this._maybeScheduleHide() } _setListeners() { d.on(this._element, ql, t => this._onInteraction(t, !0)), d.on(this._element, zl, t => this._onInteraction(t, !1)), d.on(this._element, Gl, t => this._onInteraction(t, !0)), d.on(this._element, Xl, t => this._onInteraction(t, !1)) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(t) { return this.each(function () { const e = Ke.getOrCreateInstance(this, t); if (typeof t == "string") { if (typeof e[t] > "u") throw new TypeError(`No method named "${t}"`); e[t](this) } }) } } Be(Ke); K(Ke); function hr(n, t) { return function () { return n.apply(t, arguments) } } const { toString: pr } = Object.prototype, { getPrototypeOf: Wn } = Object, Kn = (n => t => { const e = pr.call(t); return n[e] || (n[e] = e.slice(8, -1).toLowerCase()) })(Object.create(null)), rt = n => (n = n.toLowerCase(), t => Kn(t) === n), Ye = n => t => typeof t === n, { isArray: zt } = Array, ce = Ye("undefined"); function su(n) { return n !== null && !ce(n) && n.constructor !== null && !ce(n.constructor) && ft(n.constructor.isBuffer) && n.constructor.isBuffer(n) } const mr = rt("ArrayBuffer"); function iu(n) { let t; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(n) : t = n && n.buffer && mr(n.buffer), t } const ru = Ye("string"), ft = Ye("function"), _r = Ye("number"), Yn = n => n !== null && typeof n == "object", ou = n => n === !0 || n === !1, Ce = n => { if (Kn(n) !== "object") return !1; const t = Wn(n); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n) }, au = rt("Date"), cu = rt("File"), lu = rt("Blob"), uu = rt("FileList"), fu = n => Yn(n) && ft(n.pipe), du = n => { const t = "[object FormData]"; return n && (typeof FormData == "function" && n instanceof FormData || pr.call(n) === t || ft(n.toString) && n.toString() === t) }, hu = rt("URLSearchParams"), pu = n => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function he(n, t, { allOwnKeys: e = !1 } = {}) { if (n === null || typeof n > "u") return; let s, i; if (typeof n != "object" && (n = [n]), zt(n)) for (s = 0, i = n.length; s < i; s++)t.call(null, n[s], s, n); else { const r = e ? Object.getOwnPropertyNames(n) : Object.keys(n), o = r.length; let a; for (s = 0; s < o; s++)a = r[s], t.call(null, n[a], a, n) } } function Er(n, t) { t = t.toLowerCase(); const e = Object.keys(n); let s = e.length, i; for (; s-- > 0;)if (i = e[s], t === i.toLowerCase()) return i; return null } const gr = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), vr = n => !ce(n) && n !== gr; function wn() { const { caseless: n } = vr(this) && this || {}, t = {}, e = (s, i) => { const r = n && Er(t, i) || i; Ce(t[r]) && Ce(s) ? t[r] = wn(t[r], s) : Ce(s) ? t[r] = wn({}, s) : zt(s) ? t[r] = s.slice() : t[r] = s }; for (let s = 0, i = arguments.length; s < i; s++)arguments[s] && he(arguments[s], e); return t } const mu = (n, t, e, { allOwnKeys: s } = {}) => (he(t, (i, r) => { e && ft(i) ? n[r] = hr(i, e) : n[r] = i }, { allOwnKeys: s }), n), _u = n => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n), Eu = (n, t, e, s) => { n.prototype = Object.create(t.prototype, s), n.prototype.constructor = n, Object.defineProperty(n, "super", { value: t.prototype }), e && Object.assign(n.prototype, e) }, gu = (n, t, e, s) => { let i, r, o; const a = {}; if (t = t || {}, n == null) return t; do { for (i = Object.getOwnPropertyNames(n), r = i.length; r-- > 0;)o = i[r], (!s || s(o, n, t)) && !a[o] && (t[o] = n[o], a[o] = !0); n = e !== !1 && Wn(n) } while (n && (!e || e(n, t)) && n !== Object.prototype); return t }, vu = (n, t, e) => { n = String(n), (e === void 0 || e > n.length) && (e = n.length), e -= t.length; const s = n.indexOf(t, e); return s !== -1 && s === e }, bu = n => { if (!n) return null; if (zt(n)) return n; let t = n.length; if (!_r(t)) return null; const e = new Array(t); for (; t-- > 0;)e[t] = n[t]; return e }, yu = (n => t => n && t instanceof n)(typeof Uint8Array < "u" && Wn(Uint8Array)), Au = (n, t) => { const s = (n && n[Symbol.iterator]).call(n); let i; for (; (i = s.next()) && !i.done;) { const r = i.value; t.call(n, r[0], r[1]) } }, Tu = (n, t) => { let e; const s = []; for (; (e = n.exec(t)) !== null;)s.push(e); return s }, wu = rt("HTMLFormElement"), Ou = n => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (e, s, i) { return s.toUpperCase() + i }), ri = (({ hasOwnProperty: n }) => (t, e) => n.call(t, e))(Object.prototype), Su = rt("RegExp"), br = (n, t) => { const e = Object.getOwnPropertyDescriptors(n), s = {}; he(e, (i, r) => { t(i, r, n) !== !1 && (s[r] = i) }), Object.defineProperties(n, s) }, Nu = n => { br(n, (t, e) => { if (ft(n) && ["arguments", "caller", "callee"].indexOf(e) !== -1) return !1; const s = n[e]; if (ft(s)) { if (t.enumerable = !1, "writable" in t) { t.writable = !1; return } t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + e + "'") }) } }) }, Cu = (n, t) => { const e = {}, s = i => { i.forEach(r => { e[r] = !0 }) }; return zt(n) ? s(n) : s(String(n).split(t)), e }, Du = () => { }, Lu = (n, t) => (n = +n, Number.isFinite(n) ? n : t), un = "abcdefghijklmnopqrstuvwxyz", oi = "0123456789", yr = { DIGIT: oi, ALPHA: un, ALPHA_DIGIT: un + un.toUpperCase() + oi }, Ru = (n = 16, t = yr.ALPHA_DIGIT) => { let e = ""; const { length: s } = t; for (; n--;)e += t[Math.random() * s | 0]; return e }; function $u(n) { return !!(n && ft(n.append) && n[Symbol.toStringTag] === "FormData" && n[Symbol.iterator]) } const Iu = n => { const t = new Array(10), e = (s, i) => { if (Yn(s)) { if (t.indexOf(s) >= 0) return; if (!("toJSON" in s)) { t[i] = s; const r = zt(s) ? [] : {}; return he(s, (o, a) => { const c = e(o, i + 1); !ce(c) && (r[a] = c) }), t[i] = void 0, r } } return s }; return e(n, 0) }, f = { isArray: zt, isArrayBuffer: mr, isBuffer: su, isFormData: du, isArrayBufferView: iu, isString: ru, isNumber: _r, isBoolean: ou, isObject: Yn, isPlainObject: Ce, isUndefined: ce, isDate: au, isFile: cu, isBlob: lu, isRegExp: Su, isFunction: ft, isStream: fu, isURLSearchParams: hu, isTypedArray: yu, isFileList: uu, forEach: he, merge: wn, extend: mu, trim: pu, stripBOM: _u, inherits: Eu, toFlatObject: gu, kindOf: Kn, kindOfTest: rt, endsWith: vu, toArray: bu, forEachEntry: Au, matchAll: Tu, isHTMLForm: wu, hasOwnProperty: ri, hasOwnProp: ri, reduceDescriptors: br, freezeMethods: Nu, toObjectSet: Cu, toCamelCase: Ou, noop: Du, toFiniteNumber: Lu, findKey: Er, global: gr, isContextDefined: vr, ALPHABET: yr, generateString: Ru, isSpecCompliantForm: $u, toJSONObject: Iu }; function A(n, t, e, s, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = "AxiosError", t && (this.code = t), e && (this.config = e), s && (this.request = s), i && (this.response = i) } f.inherits(A, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: f.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); const Ar = A.prototype, Tr = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(n => { Tr[n] = { value: n } }); Object.defineProperties(A, Tr); Object.defineProperty(Ar, "isAxiosError", { value: !0 }); A.from = (n, t, e, s, i, r) => { const o = Object.create(Ar); return f.toFlatObject(n, o, function (c) { return c !== Error.prototype }, a => a !== "isAxiosError"), A.call(o, n.message, t, e, s, i), o.cause = n, o.name = n.name, r && Object.assign(o, r), o }; const Pu = null; function On(n) { return f.isPlainObject(n) || f.isArray(n) } function wr(n) { return f.endsWith(n, "[]") ? n.slice(0, -2) : n } function ai(n, t, e) { return n ? n.concat(t).map(function (i, r) { return i = wr(i), !e && r ? "[" + i + "]" : i }).join(e ? "." : "") : t } function xu(n) { return f.isArray(n) && !n.some(On) } const Mu = f.toFlatObject(f, {}, null, function (t) { return /^is[A-Z]/.test(t) }); function qe(n, t, e) { if (!f.isObject(n)) throw new TypeError("target must be an object"); t = t || new FormData, e = f.toFlatObject(e, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (m, v) { return !f.isUndefined(v[m]) }); const s = e.metaTokens, i = e.visitor || u, r = e.dots, o = e.indexes, c = (e.Blob || typeof Blob < "u" && Blob) && f.isSpecCompliantForm(t); if (!f.isFunction(i)) throw new TypeError("visitor must be a function"); function l(p) { if (p === null) return ""; if (f.isDate(p)) return p.toISOString(); if (!c && f.isBlob(p)) throw new A("Blob is not supported. Use a Buffer instead."); return f.isArrayBuffer(p) || f.isTypedArray(p) ? c && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p } function u(p, m, v) { let y = p; if (p && !v && typeof p == "object") { if (f.endsWith(m, "{}")) m = s ? m : m.slice(0, -2), p = JSON.stringify(p); else if (f.isArray(p) && xu(p) || (f.isFileList(p) || f.endsWith(m, "[]")) && (y = f.toArray(p))) return m = wr(m), y.forEach(function (S, b) { !(f.isUndefined(S) || S === null) && t.append(o === !0 ? ai([m], b, r) : o === null ? m : m + "[]", l(S)) }), !1 } return On(p) ? !0 : (t.append(ai(v, m, r), l(p)), !1) } const h = [], E = Object.assign(Mu, { defaultVisitor: u, convertValue: l, isVisitable: On }); function _(p, m) { if (!f.isUndefined(p)) { if (h.indexOf(p) !== -1) throw Error("Circular reference detected in " + m.join(".")); h.push(p), f.forEach(p, function (y, T) { (!(f.isUndefined(y) || y === null) && i.call(t, y, f.isString(T) ? T.trim() : T, m, E)) === !0 && _(y, m ? m.concat(T) : [T]) }), h.pop() } } if (!f.isObject(n)) throw new TypeError("data must be an object"); return _(n), t } function ci(n) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (s) { return t[s] }) } function qn(n, t) { this._pairs = [], n && qe(n, this, t) } const Or = qn.prototype; Or.append = function (t, e) { this._pairs.push([t, e]) }; Or.toString = function (t) { const e = t ? function (s) { return t.call(this, s, ci) } : ci; return this._pairs.map(function (i) { return e(i[0]) + "=" + e(i[1]) }, "").join("&") }; function ku(n) { return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Sr(n, t, e) { if (!t) return n; const s = e && e.encode || ku, i = e && e.serialize; let r; if (i ? r = i(t, e) : r = f.isURLSearchParams(t) ? t.toString() : new qn(t, e).toString(s), r) { const o = n.indexOf("#"); o !== -1 && (n = n.slice(0, o)), n += (n.indexOf("?") === -1 ? "?" : "&") + r } return n } class Hu { constructor() { this.handlers = [] } use(t, e, s) { return this.handlers.push({ fulfilled: t, rejected: e, synchronous: s ? s.synchronous : !1, runWhen: s ? s.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { f.forEach(this.handlers, function (s) { s !== null && t(s) }) } } const li = Hu, Nr = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Bu = typeof URLSearchParams < "u" ? URLSearchParams : qn, Vu = typeof FormData < "u" ? FormData : null, Uu = typeof Blob < "u" ? Blob : null, ju = (() => { let n; return typeof navigator < "u" && ((n = navigator.product) === "ReactNative" || n === "NativeScript" || n === "NS") ? !1 : typeof window < "u" && typeof document < "u" })(), Fu = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), Q = { isBrowser: !0, classes: { URLSearchParams: Bu, FormData: Vu, Blob: Uu }, isStandardBrowserEnv: ju, isStandardBrowserWebWorkerEnv: Fu, protocols: ["http", "https", "file", "blob", "url", "data"] }; function Wu(n, t) { return qe(n, new Q.classes.URLSearchParams, Object.assign({ visitor: function (e, s, i, r) { return Q.isNode && f.isBuffer(e) ? (this.append(s, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments) } }, t)) } function Ku(n) { return f.matchAll(/\w+|\[(\w*)]/g, n).map(t => t[0] === "[]" ? "" : t[1] || t[0]) } function Yu(n) { const t = {}, e = Object.keys(n); let s; const i = e.length; let r; for (s = 0; s < i; s++)r = e[s], t[r] = n[r]; return t } function Cr(n) { function t(e, s, i, r) { let o = e[r++]; const a = Number.isFinite(+o), c = r >= e.length; return o = !o && f.isArray(i) ? i.length : o, c ? (f.hasOwnProp(i, o) ? i[o] = [i[o], s] : i[o] = s, !a) : ((!i[o] || !f.isObject(i[o])) && (i[o] = []), t(e, s, i[o], r) && f.isArray(i[o]) && (i[o] = Yu(i[o])), !a) } if (f.isFormData(n) && f.isFunction(n.entries)) { const e = {}; return f.forEachEntry(n, (s, i) => { t(Ku(s), i, e, 0) }), e } return null } const qu = { "Content-Type": void 0 }; function zu(n, t, e) { if (f.isString(n)) try { return (t || JSON.parse)(n), f.trim(n) } catch (s) { if (s.name !== "SyntaxError") throw s } return (e || JSON.stringify)(n) } const ze = { transitional: Nr, adapter: ["xhr", "http"], transformRequest: [function (t, e) { const s = e.getContentType() || "", i = s.indexOf("application/json") > -1, r = f.isObject(t); if (r && f.isHTMLForm(t) && (t = new FormData(t)), f.isFormData(t)) return i && i ? JSON.stringify(Cr(t)) : t; if (f.isArrayBuffer(t) || f.isBuffer(t) || f.isStream(t) || f.isFile(t) || f.isBlob(t)) return t; if (f.isArrayBufferView(t)) return t.buffer; if (f.isURLSearchParams(t)) return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let a; if (r) { if (s.indexOf("application/x-www-form-urlencoded") > -1) return Wu(t, this.formSerializer).toString(); if ((a = f.isFileList(t)) || s.indexOf("multipart/form-data") > -1) { const c = this.env && this.env.FormData; return qe(a ? { "files[]": t } : t, c && new c, this.formSerializer) } } return r || i ? (e.setContentType("application/json", !1), zu(t)) : t }], transformResponse: [function (t) { const e = this.transitional || ze.transitional, s = e && e.forcedJSONParsing, i = this.responseType === "json"; if (t && f.isString(t) && (s && !this.responseType || i)) { const o = !(e && e.silentJSONParsing) && i; try { return JSON.parse(t) } catch (a) { if (o) throw a.name === "SyntaxError" ? A.from(a, A.ERR_BAD_RESPONSE, this, null, this.response) : a } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Q.classes.FormData, Blob: Q.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*" } } }; f.forEach(["delete", "get", "head"], function (t) { ze.headers[t] = {} }); f.forEach(["post", "put", "patch"], function (t) { ze.headers[t] = f.merge(qu) }); const zn = ze, Gu = f.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), Xu = n => {
    const t = {}; let e, s, i; return n && n.split(`
`).forEach(function (o) { i = o.indexOf(":"), e = o.substring(0, i).trim().toLowerCase(), s = o.substring(i + 1).trim(), !(!e || t[e] && Gu[e]) && (e === "set-cookie" ? t[e] ? t[e].push(s) : t[e] = [s] : t[e] = t[e] ? t[e] + ", " + s : s) }), t
}, ui = Symbol("internals"); function ne(n) { return n && String(n).trim().toLowerCase() } function De(n) { return n === !1 || n == null ? n : f.isArray(n) ? n.map(De) : String(n) } function Ju(n) { const t = Object.create(null), e = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let s; for (; s = e.exec(n);)t[s[1]] = s[2]; return t } function Qu(n) { return /^[-_a-zA-Z]+$/.test(n.trim()) } function fn(n, t, e, s, i) { if (f.isFunction(s)) return s.call(this, t, e); if (i && (t = e), !!f.isString(t)) { if (f.isString(s)) return t.indexOf(s) !== -1; if (f.isRegExp(s)) return s.test(t) } } function Zu(n) { return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, e, s) => e.toUpperCase() + s) } function tf(n, t) { const e = f.toCamelCase(" " + t);["get", "set", "has"].forEach(s => { Object.defineProperty(n, s + e, { value: function (i, r, o) { return this[s].call(this, t, i, r, o) }, configurable: !0 }) }) } class Ge {
    constructor(t) { t && this.set(t) } set(t, e, s) { const i = this; function r(a, c, l) { const u = ne(c); if (!u) throw new Error("header name must be a non-empty string"); const h = f.findKey(i, u); (!h || i[h] === void 0 || l === !0 || l === void 0 && i[h] !== !1) && (i[h || c] = De(a)) } const o = (a, c) => f.forEach(a, (l, u) => r(l, u, c)); return f.isPlainObject(t) || t instanceof this.constructor ? o(t, e) : f.isString(t) && (t = t.trim()) && !Qu(t) ? o(Xu(t), e) : t != null && r(e, t, s), this } get(t, e) { if (t = ne(t), t) { const s = f.findKey(this, t); if (s) { const i = this[s]; if (!e) return i; if (e === !0) return Ju(i); if (f.isFunction(e)) return e.call(this, i, s); if (f.isRegExp(e)) return e.exec(i); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, e) { if (t = ne(t), t) { const s = f.findKey(this, t); return !!(s && this[s] !== void 0 && (!e || fn(this, this[s], s, e))) } return !1 } delete(t, e) { const s = this; let i = !1; function r(o) { if (o = ne(o), o) { const a = f.findKey(s, o); a && (!e || fn(s, s[a], a, e)) && (delete s[a], i = !0) } } return f.isArray(t) ? t.forEach(r) : r(t), i } clear(t) { const e = Object.keys(this); let s = e.length, i = !1; for (; s--;) { const r = e[s]; (!t || fn(this, this[r], r, t, !0)) && (delete this[r], i = !0) } return i } normalize(t) { const e = this, s = {}; return f.forEach(this, (i, r) => { const o = f.findKey(s, r); if (o) { e[o] = De(i), delete e[r]; return } const a = t ? Zu(r) : String(r).trim(); a !== r && delete e[r], e[a] = De(i), s[a] = !0 }), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const e = Object.create(null); return f.forEach(this, (s, i) => { s != null && s !== !1 && (e[i] = t && f.isArray(s) ? s.join(", ") : s) }), e } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
        return Object.entries(this.toJSON()).map(([t, e]) => t + ": " + e).join(`
`)
    } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...e) { const s = new this(t); return e.forEach(i => s.set(i)), s } static accessor(t) { const s = (this[ui] = this[ui] = { accessors: {} }).accessors, i = this.prototype; function r(o) { const a = ne(o); s[a] || (tf(i, o), s[a] = !0) } return f.isArray(t) ? t.forEach(r) : r(t), this }
} Ge.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); f.freezeMethods(Ge.prototype); f.freezeMethods(Ge); const st = Ge; function dn(n, t) { const e = this || zn, s = t || e, i = st.from(s.headers); let r = s.data; return f.forEach(n, function (a) { r = a.call(e, r, i.normalize(), t ? t.status : void 0) }), i.normalize(), r } function Dr(n) { return !!(n && n.__CANCEL__) } function pe(n, t, e) { A.call(this, n ?? "canceled", A.ERR_CANCELED, t, e), this.name = "CanceledError" } f.inherits(pe, A, { __CANCEL__: !0 }); function ef(n, t, e) { const s = e.config.validateStatus; !e.status || !s || s(e.status) ? n(e) : t(new A("Request failed with status code " + e.status, [A.ERR_BAD_REQUEST, A.ERR_BAD_RESPONSE][Math.floor(e.status / 100) - 4], e.config, e.request, e)) } const nf = Q.isStandardBrowserEnv ? function () { return { write: function (e, s, i, r, o, a) { const c = []; c.push(e + "=" + encodeURIComponent(s)), f.isNumber(i) && c.push("expires=" + new Date(i).toGMTString()), f.isString(r) && c.push("path=" + r), f.isString(o) && c.push("domain=" + o), a === !0 && c.push("secure"), document.cookie = c.join("; ") }, read: function (e) { const s = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return s ? decodeURIComponent(s[3]) : null }, remove: function (e) { this.write(e, "", Date.now() - 864e5) } } }() : function () { return { write: function () { }, read: function () { return null }, remove: function () { } } }(); function sf(n) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n) } function rf(n, t) { return t ? n.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : n } function Lr(n, t) { return n && !sf(t) ? rf(n, t) : t } const of = Q.isStandardBrowserEnv ? function () { const t = /(msie|trident)/i.test(navigator.userAgent), e = document.createElement("a"); let s; function i(r) { let o = r; return t && (e.setAttribute("href", o), o = e.href), e.setAttribute("href", o), { href: e.href, protocol: e.protocol ? e.protocol.replace(/:$/, "") : "", host: e.host, search: e.search ? e.search.replace(/^\?/, "") : "", hash: e.hash ? e.hash.replace(/^#/, "") : "", hostname: e.hostname, port: e.port, pathname: e.pathname.charAt(0) === "/" ? e.pathname : "/" + e.pathname } } return s = i(window.location.href), function (o) { const a = f.isString(o) ? i(o) : o; return a.protocol === s.protocol && a.host === s.host } }() : function () { return function () { return !0 } }(); function af(n) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n); return t && t[1] || "" } function cf(n, t) { n = n || 10; const e = new Array(n), s = new Array(n); let i = 0, r = 0, o; return t = t !== void 0 ? t : 1e3, function (c) { const l = Date.now(), u = s[r]; o || (o = l), e[i] = c, s[i] = l; let h = r, E = 0; for (; h !== i;)E += e[h++], h = h % n; if (i = (i + 1) % n, i === r && (r = (r + 1) % n), l - o < t) return; const _ = u && l - u; return _ ? Math.round(E * 1e3 / _) : void 0 } } function fi(n, t) { let e = 0; const s = cf(50, 250); return i => { const r = i.loaded, o = i.lengthComputable ? i.total : void 0, a = r - e, c = s(a), l = r <= o; e = r; const u = { loaded: r, total: o, progress: o ? r / o : void 0, bytes: a, rate: c || void 0, estimated: c && o && l ? (o - r) / c : void 0, event: i }; u[t ? "download" : "upload"] = !0, n(u) } } const lf = typeof XMLHttpRequest < "u", uf = lf && function (n) { return new Promise(function (e, s) { let i = n.data; const r = st.from(n.headers).normalize(), o = n.responseType; let a; function c() { n.cancelToken && n.cancelToken.unsubscribe(a), n.signal && n.signal.removeEventListener("abort", a) } f.isFormData(i) && (Q.isStandardBrowserEnv || Q.isStandardBrowserWebWorkerEnv) && r.setContentType(!1); let l = new XMLHttpRequest; if (n.auth) { const _ = n.auth.username || "", p = n.auth.password ? unescape(encodeURIComponent(n.auth.password)) : ""; r.set("Authorization", "Basic " + btoa(_ + ":" + p)) } const u = Lr(n.baseURL, n.url); l.open(n.method.toUpperCase(), Sr(u, n.params, n.paramsSerializer), !0), l.timeout = n.timeout; function h() { if (!l) return; const _ = st.from("getAllResponseHeaders" in l && l.getAllResponseHeaders()), m = { data: !o || o === "text" || o === "json" ? l.responseText : l.response, status: l.status, statusText: l.statusText, headers: _, config: n, request: l }; ef(function (y) { e(y), c() }, function (y) { s(y), c() }, m), l = null } if ("onloadend" in l ? l.onloadend = h : l.onreadystatechange = function () { !l || l.readyState !== 4 || l.status === 0 && !(l.responseURL && l.responseURL.indexOf("file:") === 0) || setTimeout(h) }, l.onabort = function () { l && (s(new A("Request aborted", A.ECONNABORTED, n, l)), l = null) }, l.onerror = function () { s(new A("Network Error", A.ERR_NETWORK, n, l)), l = null }, l.ontimeout = function () { let p = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded"; const m = n.transitional || Nr; n.timeoutErrorMessage && (p = n.timeoutErrorMessage), s(new A(p, m.clarifyTimeoutError ? A.ETIMEDOUT : A.ECONNABORTED, n, l)), l = null }, Q.isStandardBrowserEnv) { const _ = (n.withCredentials || of(u)) && n.xsrfCookieName && nf.read(n.xsrfCookieName); _ && r.set(n.xsrfHeaderName, _) } i === void 0 && r.setContentType(null), "setRequestHeader" in l && f.forEach(r.toJSON(), function (p, m) { l.setRequestHeader(m, p) }), f.isUndefined(n.withCredentials) || (l.withCredentials = !!n.withCredentials), o && o !== "json" && (l.responseType = n.responseType), typeof n.onDownloadProgress == "function" && l.addEventListener("progress", fi(n.onDownloadProgress, !0)), typeof n.onUploadProgress == "function" && l.upload && l.upload.addEventListener("progress", fi(n.onUploadProgress)), (n.cancelToken || n.signal) && (a = _ => { l && (s(!_ || _.type ? new pe(null, n, l) : _), l.abort(), l = null) }, n.cancelToken && n.cancelToken.subscribe(a), n.signal && (n.signal.aborted ? a() : n.signal.addEventListener("abort", a))); const E = af(u); if (E && Q.protocols.indexOf(E) === -1) { s(new A("Unsupported protocol " + E + ":", A.ERR_BAD_REQUEST, n)); return } l.send(i || null) }) }, Le = { http: Pu, xhr: uf }; f.forEach(Le, (n, t) => { if (n) { try { Object.defineProperty(n, "name", { value: t }) } catch { } Object.defineProperty(n, "adapterName", { value: t }) } }); const ff = { getAdapter: n => { n = f.isArray(n) ? n : [n]; const { length: t } = n; let e, s; for (let i = 0; i < t && (e = n[i], !(s = f.isString(e) ? Le[e.toLowerCase()] : e)); i++); if (!s) throw s === !1 ? new A(`Adapter ${e} is not supported by the environment`, "ERR_NOT_SUPPORT") : new Error(f.hasOwnProp(Le, e) ? `Adapter '${e}' is not available in the build` : `Unknown adapter '${e}'`); if (!f.isFunction(s)) throw new TypeError("adapter is not a function"); return s }, adapters: Le }; function hn(n) { if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted) throw new pe(null, n) } function di(n) { return hn(n), n.headers = st.from(n.headers), n.data = dn.call(n, n.transformRequest), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1), ff.getAdapter(n.adapter || zn.adapter)(n).then(function (s) { return hn(n), s.data = dn.call(n, n.transformResponse, s), s.headers = st.from(s.headers), s }, function (s) { return Dr(s) || (hn(n), s && s.response && (s.response.data = dn.call(n, n.transformResponse, s.response), s.response.headers = st.from(s.response.headers))), Promise.reject(s) }) } const hi = n => n instanceof st ? n.toJSON() : n; function Wt(n, t) { t = t || {}; const e = {}; function s(l, u, h) { return f.isPlainObject(l) && f.isPlainObject(u) ? f.merge.call({ caseless: h }, l, u) : f.isPlainObject(u) ? f.merge({}, u) : f.isArray(u) ? u.slice() : u } function i(l, u, h) { if (f.isUndefined(u)) { if (!f.isUndefined(l)) return s(void 0, l, h) } else return s(l, u, h) } function r(l, u) { if (!f.isUndefined(u)) return s(void 0, u) } function o(l, u) { if (f.isUndefined(u)) { if (!f.isUndefined(l)) return s(void 0, l) } else return s(void 0, u) } function a(l, u, h) { if (h in t) return s(l, u); if (h in n) return s(void 0, l) } const c = { url: r, method: r, data: r, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: a, headers: (l, u) => i(hi(l), hi(u), !0) }; return f.forEach(Object.keys(n).concat(Object.keys(t)), function (u) { const h = c[u] || i, E = h(n[u], t[u], u); f.isUndefined(E) && h !== a || (e[u] = E) }), e } const Rr = "1.3.4", Gn = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((n, t) => { Gn[n] = function (s) { return typeof s === n || "a" + (t < 1 ? "n " : " ") + n } }); const pi = {}; Gn.transitional = function (t, e, s) { function i(r, o) { return "[Axios v" + Rr + "] Transitional option '" + r + "'" + o + (s ? ". " + s : "") } return (r, o, a) => { if (t === !1) throw new A(i(o, " has been removed" + (e ? " in " + e : "")), A.ERR_DEPRECATED); return e && !pi[o] && (pi[o] = !0, console.warn(i(o, " has been deprecated since v" + e + " and will be removed in the near future"))), t ? t(r, o, a) : !0 } }; function df(n, t, e) { if (typeof n != "object") throw new A("options must be an object", A.ERR_BAD_OPTION_VALUE); const s = Object.keys(n); let i = s.length; for (; i-- > 0;) { const r = s[i], o = t[r]; if (o) { const a = n[r], c = a === void 0 || o(a, r, n); if (c !== !0) throw new A("option " + r + " must be " + c, A.ERR_BAD_OPTION_VALUE); continue } if (e !== !0) throw new A("Unknown option " + r, A.ERR_BAD_OPTION) } } const Sn = { assertOptions: df, validators: Gn }, ct = Sn.validators; class xe { constructor(t) { this.defaults = t, this.interceptors = { request: new li, response: new li } } request(t, e) { typeof t == "string" ? (e = e || {}, e.url = t) : e = t || {}, e = Wt(this.defaults, e); const { transitional: s, paramsSerializer: i, headers: r } = e; s !== void 0 && Sn.assertOptions(s, { silentJSONParsing: ct.transitional(ct.boolean), forcedJSONParsing: ct.transitional(ct.boolean), clarifyTimeoutError: ct.transitional(ct.boolean) }, !1), i !== void 0 && Sn.assertOptions(i, { encode: ct.function, serialize: ct.function }, !0), e.method = (e.method || this.defaults.method || "get").toLowerCase(); let o; o = r && f.merge(r.common, r[e.method]), o && f.forEach(["delete", "get", "head", "post", "put", "patch", "common"], p => { delete r[p] }), e.headers = st.concat(o, r); const a = []; let c = !0; this.interceptors.request.forEach(function (m) { typeof m.runWhen == "function" && m.runWhen(e) === !1 || (c = c && m.synchronous, a.unshift(m.fulfilled, m.rejected)) }); const l = []; this.interceptors.response.forEach(function (m) { l.push(m.fulfilled, m.rejected) }); let u, h = 0, E; if (!c) { const p = [di.bind(this), void 0]; for (p.unshift.apply(p, a), p.push.apply(p, l), E = p.length, u = Promise.resolve(e); h < E;)u = u.then(p[h++], p[h++]); return u } E = a.length; let _ = e; for (h = 0; h < E;) { const p = a[h++], m = a[h++]; try { _ = p(_) } catch (v) { m.call(this, v); break } } try { u = di.call(this, _) } catch (p) { return Promise.reject(p) } for (h = 0, E = l.length; h < E;)u = u.then(l[h++], l[h++]); return u } getUri(t) { t = Wt(this.defaults, t); const e = Lr(t.baseURL, t.url); return Sr(e, t.params, t.paramsSerializer) } } f.forEach(["delete", "get", "head", "options"], function (t) { xe.prototype[t] = function (e, s) { return this.request(Wt(s || {}, { method: t, url: e, data: (s || {}).data })) } }); f.forEach(["post", "put", "patch"], function (t) { function e(s) { return function (r, o, a) { return this.request(Wt(a || {}, { method: t, headers: s ? { "Content-Type": "multipart/form-data" } : {}, url: r, data: o })) } } xe.prototype[t] = e(), xe.prototype[t + "Form"] = e(!0) }); const Re = xe; class Xn { constructor(t) { if (typeof t != "function") throw new TypeError("executor must be a function."); let e; this.promise = new Promise(function (r) { e = r }); const s = this; this.promise.then(i => { if (!s._listeners) return; let r = s._listeners.length; for (; r-- > 0;)s._listeners[r](i); s._listeners = null }), this.promise.then = i => { let r; const o = new Promise(a => { s.subscribe(a), r = a }).then(i); return o.cancel = function () { s.unsubscribe(r) }, o }, t(function (r, o, a) { s.reason || (s.reason = new pe(r, o, a), e(s.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { if (this.reason) { t(this.reason); return } this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const e = this._listeners.indexOf(t); e !== -1 && this._listeners.splice(e, 1) } static source() { let t; return { token: new Xn(function (i) { t = i }), cancel: t } } } const hf = Xn; function pf(n) { return function (e) { return n.apply(null, e) } } function mf(n) { return f.isObject(n) && n.isAxiosError === !0 } const Nn = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(Nn).forEach(([n, t]) => { Nn[t] = n }); const _f = Nn; function $r(n) { const t = new Re(n), e = hr(Re.prototype.request, t); return f.extend(e, Re.prototype, t, { allOwnKeys: !0 }), f.extend(e, t, null, { allOwnKeys: !0 }), e.create = function (i) { return $r(Wt(n, i)) }, e } const D = $r(zn); D.Axios = Re; D.CanceledError = pe; D.CancelToken = hf; D.isCancel = Dr; D.VERSION = Rr; D.toFormData = qe; D.AxiosError = A; D.Cancel = D.CanceledError; D.all = function (t) { return Promise.all(t) }; D.spread = pf; D.isAxiosError = mf; D.mergeConfig = Wt; D.AxiosHeaders = st; D.formToJSON = n => Cr(f.isHTMLForm(n) ? new FormData(n) : n); D.HttpStatusCode = _f; D.default = D; const Ef = D; window.axios = Ef; window.axios.defaults.headers.common["X-Requested-With"] = "XMLHttpRequest";
